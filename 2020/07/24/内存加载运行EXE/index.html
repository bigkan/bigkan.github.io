<!DOCTYPE html><html lang="zh-Hans"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 内存加载运行EXE · 杂毛小鸡</title><meta name="description" content="内存加载运行EXE - 杂毛小鸡"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon2.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://bigkan.github.io/atom.xml" title="杂毛小鸡"></head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon2.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/bigkan" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">内存加载运行EXE</h1><div class="post-info">Jul 24, 2020</div><div class="post-content"><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><blockquote>
<p>如何将其他程序加载到内存中运行？有点类似exe加载器。A.exe将B.exe加载到内存中运行需要几步？只需要4步</p>
<ul>
<li>第一步：将B.exe读取到内存中并拉伸</li>
<li>第二步：修复B.exe的IAT表</li>
<li>第三步：修复B.exe的重定位表</li>
<li>第四步：运行B.exe</li>
</ul>
</blockquote>
<a id="more"></a>
<h1 id="一、将B-exe读取到内存并拉伸"><a href="#一、将B-exe读取到内存并拉伸" class="headerlink" title="一、将B.exe读取到内存并拉伸"></a>一、将B.exe读取到内存并拉伸</h1><p>要将B.exe加载到A.exe中运行，第一步当然是要将B加载到A的内存中并按照IMAGE_SECTION_HEADER对B进行拉伸。</p>
<p><img src="/2020/07/24/内存加载运行EXE/FileToMem.png" alt="文件加载到内存"></p>
<h3 id="1-将B-exe读取到内存中"><a href="#1-将B-exe读取到内存中" class="headerlink" title="1. 将B.exe读取到内存中"></a>1. 将B.exe读取到内存中</h3><p>将B.exe整个读入到A.exe的内存中。这里就不放代码了。</p>
<h3 id="2-计算B-exe需要的内存大小"><a href="#2-计算B-exe需要的内存大小" class="headerlink" title="2. 计算B.exe需要的内存大小"></a>2. 计算B.exe需要的内存大小</h3><p>第一种方法，在PE OptionalHeader的SizeOfImage记录有内存占用大小。</p>
<p>第二种方法，可以通过最后一个SectionHeader的VirtualAddress加上内存对齐后的SizeOfRawData得到另一个内存占用大小。</p>
<p>取两个方法中较大的那个作为内存占用大小</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内存镜像大小</span></span><br><span class="line">DWORD size_image = OptionalHeader-&gt;SizeOfImage;</span><br><span class="line"><span class="comment">//计算最后一个节内存对齐后需要多大空间</span></span><br><span class="line"><span class="keyword">int</span> size = last_section.SizeOfRawData / mem_Alignment;</span><br><span class="line">size = (size + (last_section.SizeOfRawData % mem_Alignment == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>)) * mem_Alignment;	</span><br><span class="line">SIZE_T fileBufferSize = last_section.VirtualAddress + size;</span><br><span class="line"><span class="comment">//比较大小</span></span><br><span class="line">fileBufferSize = size_image &gt; fileBufferSize ? size_image : fileBufferSize;</span><br><span class="line"><span class="comment">//开辟空间</span></span><br><span class="line">*i_buff = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(fileBufferSize);</span><br></pre></td></tr></table></figure>
<h3 id="3-根据sectionHeader对PE进行拉伸"><a href="#3-根据sectionHeader对PE进行拉伸" class="headerlink" title="3. 根据sectionHeader对PE进行拉伸"></a>3. 根据sectionHeader对PE进行拉伸</h3><p>下面是IMAGE_SECTION_HEADER结构体，其中最重要的是VirtualAddress：相对偏移地址（RVA）用于计算节复制的目的地址。SizeOfRawData:节在文本中的大小，用于计算内存对齐后的大小。PointerToRawData：文本中的相对偏移（FOA）用于计算复制节的源地址。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">            DWORD   PhysicalAddress;</span><br><span class="line">            DWORD   VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    DWORD   VirtualAddress;             <span class="comment">//内存中的相对偏移地址，RVA地址</span></span><br><span class="line">    DWORD   SizeOfRawData;              <span class="comment">//未拉伸时节大小</span></span><br><span class="line">    DWORD   PointerToRawData;           <span class="comment">//文本中节的相对偏移地址，FOA地址</span></span><br><span class="line">    DWORD   PointerToRelocations;</span><br><span class="line">    DWORD   PointerToLinenumbers;</span><br><span class="line">    WORD    NumberOfRelocations;</span><br><span class="line">    WORD    NumberOfLinenumbers;</span><br><span class="line">    DWORD   Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure></p>
<p>循环将节从FileBuff中复制到ImageBuff<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; sectionNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">	DWORD vAddr = section_header[i].VirtualAddress;</span><br><span class="line">	DWORD point_section = section_header[i].PointerToRawData;</span><br><span class="line">	DWORD size_section = section_header[i].SizeOfRawData;</span><br><span class="line">	<span class="comment">//计算内存对齐后的大小	</span></span><br><span class="line">	<span class="keyword">if</span> (size_section % mem_Alignment != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		section_header[i].SizeOfRawData = (size_section / mem_Alignment + (size_section % mem_Alignment == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>)) * mem_Alignment;</span><br><span class="line">	&#125;</span><br><span class="line">	section_header[i].PointerToRawData = vAddr;</span><br><span class="line">    <span class="comment">//从thePeHeaders-&gt;fileBuff + point_section复制size_section到temp_ibuff + vAddr中</span></span><br><span class="line">	<span class="built_in">memcpy</span>(temp_ibuff + vAddr, thePeHeaders-&gt;fileBuff + point_section, size_section);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*拷贝头部信息， 后面两种方式都可以</span></span><br><span class="line"><span class="comment">1.取出可选PE头中的 header大小描述 _nt_header-&gt;OptionalHeader.SizeOfHeaders</span></span><br><span class="line"><span class="comment">2.判断第一个节的文件偏移位置 _section_header[0].PointerToRawData</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">DWORD header_offset = section_header[<span class="number">0</span>].PointerToRawData;</span><br><span class="line"><span class="built_in">memcpy</span>(temp_ibuff, thePeHeaders-&gt;fileBuff, header_offset);</span><br></pre></td></tr></table></figure></p>
<h3 id="4-VirtualAlloc"><a href="#4-VirtualAlloc" class="headerlink" title="4. VirtualAlloc"></a>4. VirtualAlloc</h3><p>根据ImageBase和之前计算的拉伸后PE大小，VirtualAlloc开辟空间，并将上一步拉伸的PE复制到新开辟的空间中<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CHAR* vir = (CHAR*)VirtualAlloc((LPVOID)imageBase, sizeOfImage, MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line"><span class="keyword">if</span> (vir == <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    MessageBox(<span class="literal">NULL</span>, <span class="string">L"内存申请失败!"</span>, <span class="string">L"信息提示"</span>, MB_ICONERROR);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">memcpy</span>(vir, imageBuff, sizeOfImage);</span><br></pre></td></tr></table></figure></p>
<h1 id="二、修复IAT表"><a href="#二、修复IAT表" class="headerlink" title="二、修复IAT表"></a>二、修复IAT表</h1><p>当PE程序使用其他DLL时需要将DLL加载到内存中并获得需要使用函数的地址。PE文件加载时，会根据导入表将程序需要的DLL加载到内存中，并将对应函数的地址填入到IAT表中。这里由于是我们自己加载拉伸的PE所以拉伸后的IAT表并没有修复，需要我们手动进行。</p>
<p>在PE加载前导入表的状态如下图所示，IAT表中记录的内容和INT记录的内容相同</p>
<p><img src="/2020/07/24/内存加载运行EXE/IAT1.png" alt="文件加载到内存"></p>
<p>在PE加载后导入表的状态如下图所示，IAT表将记录DLL中导入的函数地址</p>
<p><img src="/2020/07/24/内存加载运行EXE/IAT2.png" alt="文件加载到内存"></p>
<h3 id="1-遍历IMAGE-IMPORT-DESCRIPTOR表"><a href="#1-遍历IMAGE-IMPORT-DESCRIPTOR表" class="headerlink" title="1. 遍历IMAGE_IMPORT_DESCRIPTOR表"></a>1. 遍历IMAGE_IMPORT_DESCRIPTOR表</h3><p>每个IMAGE_IMPORT_DESCRIPTOR结构描述了一个需要导入的DLL。其中最重要的是OriginalFirstThunk：指向INT表，用于GetProcAddress获得对应函数地址。Name：指向需要DLL的名字，用于LoadLibraryA将DLL加载到内存中。FirstThunk：指向IAT表，需要将获得的函数地址填入到IAT表中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD   Characteristics;            <span class="comment">// 0 for terminating null import descriptor</span></span><br><span class="line">        DWORD   OriginalFirstThunk;         <span class="comment">// RVA to original unbound IAT (PIMAGE_THUNK_DATA)</span></span><br><span class="line">    &#125; DUMMYUNIONNAME;</span><br><span class="line">    DWORD   TimeDateStamp;                  <span class="comment">// 0 if not bound,</span></span><br><span class="line">                                            <span class="comment">// -1 if bound, and real date\time stamp</span></span><br><span class="line">                                            <span class="comment">//     in IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT (new BIND)</span></span><br><span class="line">                                            <span class="comment">// O.W. date/time stamp of DLL bound to (Old BIND)</span></span><br><span class="line"></span><br><span class="line">    DWORD   ForwarderChain;                 <span class="comment">// -1 if no forwarders</span></span><br><span class="line">    DWORD   Name;</span><br><span class="line">    DWORD   FirstThunk;                     <span class="comment">// RVA to IAT (if bound this IAT has actual addresses)</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_IMPORT_DESCRIPTOR UNALIGNED *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>
<h3 id="2-遍历INT表获取函数地址"><a href="#2-遍历INT表获取函数地址" class="headerlink" title="2. 遍历INT表获取函数地址"></a>2. 遍历INT表获取函数地址</h3><p>INT表指向的是需要使用的函数名字，需要遍历INT表通过GetProcAddress获得函数的地址,并将得到的函数地址填入到IAT表对应的位置</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//循环导出表结构体，遍历所要调用的所有PE模块 判断结构标记</span></span><br><span class="line"><span class="keyword">while</span> (impTable-&gt;OriginalFirstThunk != <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">	_IMAGE_THUNK_DATA32* IntThunkData = (_IMAGE_THUNK_DATA32*)(pData + impTable-&gt;OriginalFirstThunk);</span><br><span class="line">	_IMAGE_THUNK_DATA32* IatThunkData = (_IMAGE_THUNK_DATA32*)(pData + impTable-&gt;FirstThunk);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//遍历导入表  根据DLL名称加载DLL</span></span><br><span class="line">	HMODULE dllModule = LoadLibraryA(pData + impTable-&gt;Name);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">//判断INT表结束标记</span></span><br><span class="line">	<span class="keyword">while</span> (IntThunkData-&gt;u1.Ordinal != <span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">//获取导入表的名字</span></span><br><span class="line">		DWORD numOrName = IntThunkData-&gt;u1.Ordinal;</span><br><span class="line">		<span class="comment">//取出标记 判断为序号导入还是名字导入</span></span><br><span class="line">		DWORD flag = numOrName &amp; <span class="number">0x80000000</span>;</span><br><span class="line"></span><br><span class="line">		PDWORD addTemp = (PDWORD)IatThunkData;</span><br><span class="line">		<span class="keyword">if</span> (flag == <span class="number">0x80000000</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			DWORD number = numOrName &amp; <span class="number">0x7FFFFFFF</span>;</span><br><span class="line">			<span class="comment">//序号导入</span></span><br><span class="line">			<span class="comment">//修复导入表中按序号导入的函数地址</span></span><br><span class="line">			DWORD funAddr = (DWORD)GetProcAddress(dllModule, MAKEINTRESOURCEA(number));</span><br><span class="line">			*addTemp = funAddr;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			CHAR* namefoaAddr = numOrName + pData;</span><br><span class="line">			IMAGE_IMPORT_BY_NAME* impByName = (IMAGE_IMPORT_BY_NAME*)namefoaAddr;</span><br><span class="line">			<span class="comment">//修复导入表中按名字导入的函数地址</span></span><br><span class="line">			DWORD funAddr = (DWORD)GetProcAddress(dllModule, (LPCSTR)impByName-&gt;Name);</span><br><span class="line">			*addTemp = funAddr;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">"按名字导入Name:%s funAddr:%x dllName:%s"</span>, impByName-&gt;Name, funAddr, pData + impTable-&gt;Name);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//指向下一个INT表</span></span><br><span class="line">		IntThunkData++;</span><br><span class="line">		<span class="comment">//指向下一个IAT表</span></span><br><span class="line">		IatThunkData++;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//指向下一个导入表 结构体</span></span><br><span class="line">	impTable++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="三、修复重定位表"><a href="#三、修复重定位表" class="headerlink" title="三、修复重定位表"></a>三、修复重定位表</h1><p>PE文件中有些地址使用的是绝对地址而不是相对地址，所以当PE文件没有被贴到ImageBase指定的地址时，需要对这些地址进行重定位。<strong>修正方法：需要重定位的地址 - 以前的基址 + 当前的基址。</strong></p>
<p><img src="/2020/07/24/内存加载运行EXE/Reloc.png" alt="文件加载到内存"></p>
<h3 id="1-遍历IMAGE-BASE-RELOCATION"><a href="#1-遍历IMAGE-BASE-RELOCATION" class="headerlink" title="1.遍历IMAGE_BASE_RELOCATION"></a>1.遍历IMAGE_BASE_RELOCATION</h3><p>这个结构包括两个DWORD，VirtualAddress：表示需要重定位的<strong>内存页</strong>的相对虚拟地址。SizeOfBlock：表示当前重定位块的大小（包括VirutalAddress和SizeOfBlock的8个字节）<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD   VirtualAddress;</span><br><span class="line">    DWORD   SizeOfBlock;</span><br><span class="line"><span class="comment">//  WORD    TypeOffset[1];</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION;</span><br><span class="line"><span class="keyword">typedef</span> IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-遍历重定位条目进行重定位"><a href="#2-遍历重定位条目进行重定位" class="headerlink" title="2.遍历重定位条目进行重定位"></a>2.遍历重定位条目进行重定位</h3><p>每个条目的前4个比特表示属性，如果为3表示是重定位的有效数据，剩下的12个比特正好表示4kB的偏移恰好覆盖一个内存页的大小。剩下的事情就是计算新的重定位地址。这里为了简单加载PE时VirtualAlloc的地址就为ImageBase，所以不进行重定位页能够运行。为了程序的兼容性还是补充了一下。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修复重定位表 拉伸后的状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">restoreIbuffRelocationTable</span><span class="params">(<span class="keyword">char</span>* i_buff)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	PIMAGE_DOS_HEADER dos = (PIMAGE_DOS_HEADER)i_buff;</span><br><span class="line">	PIMAGE_NT_HEADERS nt = (PIMAGE_NT_HEADERS)(i_buff + dos-&gt;e_lfanew);</span><br><span class="line">	PIMAGE_DATA_DIRECTORY data_table = nt-&gt;OptionalHeader.DataDirectory;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//重建重定位表的指针</span></span><br><span class="line">	PIMAGE_BASE_RELOCATION first_relocation_table_addr = (PIMAGE_BASE_RELOCATION)(i_buff + data_table[<span class="number">5</span>].VirtualAddress);</span><br><span class="line">	DWORD image_base = nt-&gt;OptionalHeader.ImageBase;</span><br><span class="line">	DWORD image_base_offset = ((DWORD)i_buff - image_base);</span><br><span class="line">	<span class="keyword">int</span> lump_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (first_relocation_table_addr-&gt;SizeOfBlock &gt; <span class="number">0xA</span> &amp;&amp; first_relocation_table_addr-&gt;VirtualAddress)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"重定位表第%d块开始============\n"</span>,++lump_count);</span><br><span class="line">		DWORD block = first_relocation_table_addr-&gt;SizeOfBlock;</span><br><span class="line">		DWORD virtual_addr = first_relocation_table_addr-&gt;VirtualAddress;</span><br><span class="line">		<span class="comment">//计算重定位表中的每个块中所包含的地址数量</span></span><br><span class="line">		<span class="keyword">size_t</span> addr_count = (block - <span class="keyword">sizeof</span>(block)-<span class="keyword">sizeof</span>(virtual_addr)) / <span class="keyword">sizeof</span>(WORD);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"本块中共 %d个地址\n"</span>, addr_count);</span><br><span class="line">		WORD* temp_relocation = (WORD*)first_relocation_table_addr;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"block:%d\t | virtual_addr:%x\t | addr_count:%d\n"</span>,block, virtual_addr,addr_count);</span><br><span class="line">		temp_relocation += <span class="number">4</span>;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; addr_count; i++)</span><br><span class="line">		&#123;</span><br><span class="line">			WORD relocation_addr = *temp_relocation;</span><br><span class="line">			<span class="keyword">int</span> valid_flag = relocation_addr &gt;&gt; <span class="number">12</span>;</span><br><span class="line">			<span class="keyword">if</span> (valid_flag == <span class="number">3</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				DWORD valid_relocation_addr = virtual_addr + (relocation_addr &amp; <span class="number">0x0fff</span>);</span><br><span class="line">				<span class="keyword">char</span>* changeAddr = i_buff + valid_relocation_addr;</span><br><span class="line">				DWORD changeAddrNum = *((DWORD*)changeAddr);</span><br><span class="line">				*((DWORD*)changeAddr) = changeAddrNum + image_base_offset;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"有效地址:%2d: %XH Base的值为:%XH \n"</span>, i + <span class="number">1</span>, valid_relocation_addr, virtual_addr);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">"无效地址%2d: - \t\t - \n"</span>, i + <span class="number">1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">			temp_relocation += <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		first_relocation_table_addr = (PIMAGE_BASE_RELOCATION)(((<span class="keyword">char</span>*)first_relocation_table_addr) + block);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"重定位表第%d块结束=============\n"</span>, lump_count);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"重定位表共有%d块"</span>, lump_count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="四、加载运行"><a href="#四、加载运行" class="headerlink" title="四、加载运行"></a>四、加载运行</h1><p>剩下的事情就是CreateThread并将运行函数的地址设置为OEP<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程 执行加载的exe入口函数</span></span><br><span class="line">HANDLE executeThread = CreateThread(<span class="literal">NULL</span>, <span class="number">0</span>, (LPTHREAD_START_ROUTINE)(vir + thePeHeaders.OptionalHeader-&gt;AddressOfEntryPoint), <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">//等待加载的可执行文件执行完毕 程序退出</span></span><br><span class="line">WaitForSingleObject(executeThread, INFINITE);</span><br></pre></td></tr></table></figure></p>
<h1 id="五、编译设置"><a href="#五、编译设置" class="headerlink" title="五、编译设置"></a>五、编译设置</h1><p>为了将程序加载到原来的ImageBase（大部分程序的Imagebase都是0x400000）,需要将这个地址空出来。vs2019可以通过项目-》属性-》连接器-》高级 进行设置。将其中的基址设为0x2000000。随机基址设置为：否。固定基址设置为是。如下图所示</p>
<p><img src="/2020/07/24/内存加载运行EXE/项目设置.png" alt="文件加载到内存"></p>
<h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p>打造自己的PE解释器：<a href="https://bbs.pediy.com/thread-252795.htm" target="_blank" rel="noopener">https://bbs.pediy.com/thread-252795.htm</a></p>
<p>代码主要参考：<a href="https://github.com/18310799137/LoadExe" target="_blank" rel="noopener">https://github.com/18310799137/LoadExe</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/2019/09/16/z3学习笔记-实战两道ctf题目/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 - 2020 <a href="https://bigkan.github.io">杂毛小鸡</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>